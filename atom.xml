<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DaraW</title>
  
  <subtitle>Code is Poetry</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.daraw.cn/"/>
  <updated>2019-12-19T08:47:41.553Z</updated>
  <id>https://blog.daraw.cn/</id>
  
  <author>
    <name>DaraW</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 应用性能优化一例</title>
    <link href="https://blog.daraw.cn/2019/07/02/react-performence/"/>
    <id>https://blog.daraw.cn/2019/07/02/react-performence/</id>
    <published>2019-07-02T21:26:00.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在我们的应用中有一个存储在 Redux 中的全局状态机，保存着整个应用的核心状态，其类型大概如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> FSMStatus &#123;</span><br><span class="line">    Unknown = <span class="number">0</span>,</span><br><span class="line">    Active = <span class="number">1</span>,</span><br><span class="line">    Inactive = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> FSM &#123;</span><br><span class="line">    global_id: <span class="built_in">number</span>; <span class="comment">// 状态机实例的全局唯一 ID</span></span><br><span class="line">    timestamp: <span class="built_in">number</span>; <span class="comment">// 当前时间，每隔一秒会变化</span></span><br><span class="line">    fsm_status: FSMStatus; <span class="comment">// 整个状态机的状态</span></span><br><span class="line">    x_mod_status: FSMStatus; <span class="comment">// x 模块的状态</span></span><br><span class="line">    x_mod_data: <span class="built_in">any</span>; <span class="comment">// x 模块的核心数据</span></span><br><span class="line">    y_mod_status: FSMStatus; <span class="comment">// y 模块的状态</span></span><br><span class="line">    y_mod_data: <span class="built_in">any</span>; <span class="comment">// y 模块的核心数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些 React 组件，其中 <code>Main</code> 组件包含了 <code>Inner</code> 组件，<code>Inner</code> 组件中使用了 <code>rc-tooltip</code> 实现了弹窗效果。弹窗中有一个列表，列表中有一条带有特殊样式的处于激活状态的数据，且可以通过按键操作切换处于激活状态的数据项。  </p><p>某天突然用户报告说操作弹窗列表时感到卡顿，而且在弹窗开着的时候其他模块会明显感觉比较卡。</p><a id="more"></a><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="定位原因"><a href="#定位原因" class="headerlink" title="定位原因"></a>定位原因</h3><p>拉上一个大佬一起帮忙看了 Performence 的相关信息，发现大部分掉帧时伴随着大量 CPU 占用，而相关时间段内大部分 CPU 耗时在 DOM 操作上，DOM 操作的来源在于缩略图所使用的 <code>rc-tooltip</code> 组件和和其使用的 <code>dom-align</code> 库。</p><p>通过阅读 <code>rc-tooltip</code> 相关实现源码得知，每次组件重新渲染时都需要重新计算相关的位置信息，以保证浮层以正确的大小展示在正确的位置。即这一块很难有优化空间，在现有的需求下放弃使用 <code>rc-tooltip</code> 我们也不大可能能写出一个性能明显更好的库。</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>直觉猜测是上层业务组件（<code>Inner</code>）使用了 <code>fsm</code> 作为 <code>props</code> 的一部分，而 <code>fsm</code> 的频繁更新导致了组件的频繁重新渲染。<br>为了验证猜测，打开 <code>rc-tooltip</code> 弹窗，但不进行任何操作，录制性能信息，发现果然伴随着时间的变化（<code>fsm</code> 的变化），会出现来自 <code>rc-tooltip</code> 的 DOM 操作，即验证了猜测。</p><p>于是开始着手优化 <code>Inner</code> 组件，从 <code>fsm</code> 中只挑出使用到的属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pick <span class="keyword">from</span> <span class="string">'lodash/pick'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和实际情况作了一定简化</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="function">(<span class="params">&#123; store &#125;: &#123; store: Store &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// before</span></span><br><span class="line">    <span class="comment">// return &#123;</span></span><br><span class="line">    <span class="comment">//     fsm: store.fsm</span></span><br><span class="line">    <span class="comment">//     user_id: store.user_id</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// after</span></span><br><span class="line">    <span class="keyword">const</span> fsm = pick(store.fsm, [<span class="string">'x_mod_status'</span>, <span class="string">'y_mod_status'</span>]);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        fsm，</span><br><span class="line">        user_id: store.user_id</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(Toolbar);</span><br></pre></td></tr></table></figure><p>并将 <code>React.Component</code> 更换为 <code>React.PureComponent</code>，以获取自动化的 <code>shouldComponentUpdate</code> 检查。</p><p>但是在这一顿操作时候性能依然没有得到改善，debug 后发现实际每次 <code>props.fsm</code> 都是新构造的对象，而 <code>React.PureComponent</code> 自动化的 <code>shouldComponentUpdate</code> 检查只会做 shallow compare，导致了前一次与后一次的 <code>props</code> 不相等，<code>shouldComponentUpdate</code> 永远返回 <code>false</code>。<br>于是自己手动填充 <code>shouldComponentUpdate</code> 的逻辑，借助 <code>lodash/isEqual</code> 对 <code>props</code> 和 <code>state</code> 做 deep compare ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isEqual <span class="keyword">from</span> <span class="string">'lodash/isEqual'</span>;</span><br><span class="line"></span><br><span class="line">shouldComponentUpdate(prevProps: IProps, prevState: IState) &#123;</span><br><span class="line">    <span class="comment">// 每次的 fsm 都是新的对象，shallow compare 会认为变化了，需要 deep compare</span></span><br><span class="line">    <span class="keyword">return</span> !(isEqual(prevProps, <span class="keyword">this</span>.props) &amp;&amp; isEqual(prevState, <span class="keyword">this</span>.state));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次测试，在静止状态下 <code>fsm</code> 的变化不再触发 <code>rc-tooltip</code> 的重新渲染。但是在按住按键不放快速切换激活项的情况下，依然有卡顿感。通过观察 Performence 录制的信息，发现 <code>setState</code> 的性能损耗也很可观，在其调用链上发现最终和上面一样触发了 <code>rc-tooltip</code> 的重新渲染。</p><p>通过阅读代码发现在 <code>Main</code> 组件中存储了列表中激活状态的数据，并将这个状态从 <code>Props</code> 中依次传给了 <code>Inner</code> 、<code>rc-tooltip</code> 中的列表组件 ，在按住按键不放的时候，按键事件的回调中会不断 <code>setState</code> 更新激活状态的数据 ，从而导致组件从 <code>Main</code> 开始依次往下重新渲染，在 <code>Inner</code> 这里触发了 <code>rc-tooltip</code> 的重新渲染。</p><p>直觉的思路是在组件内部存储一个私有变量，延迟并批量进行 <code>setState</code> 的调用，但想了下这样并不可行，因为列表页当前被激活的选项的 CSS 样式效果是需要实时跟着当前状态变化的。</p><p>批量更新的思路不可行，只能想办法把这个被频繁更新的状态和使用了 <code>rc-tooltip</code> 的 <code>Inner</code> 剥离开来，从而避免 <code>Inner</code> 的重新渲染和 <code>rc-tooltip</code> 的重新渲染。通过阅读代码，发现这个状态实际只有列表组件才会使用到，于是将该状态和部分逻辑剥离到最下层的列表组件中。</p><p>经过再次修改后，验证发现这一块不再有性能问题了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h3 id="尽可能细化使用到的对象-props-属性"><a href="#尽可能细化使用到的对象-props-属性" class="headerlink" title="尽可能细化使用到的对象 props 属性"></a>尽可能细化使用到的对象 props 属性</h3><p>不要直接将整个 <code>fsm</code> 挂在 props 上，由于它是个对象，且上面有很多无关的信息在频繁地更新，即使 deep compare 也可能会因为不相关的属性变化带来不必要的重新渲染。</p><p>因此要么借助 <code>lodash/pick</code> 将 <code>fsm</code> 使用到的属性 <code>pick</code> 出来，并在 <code>shouldComponentUpdate</code> 中借助 <code>lodash/isEqual</code> 进行 deep compare ；要么将 <code>fsm</code> 上使用到的属性直接挂到 <code>props</code> 上（但是这对 <code>xx_data</code> 这种对象依然无解），并配合 <code>React.PureComponent</code> 使用。</p><h3 id="尽可能将-state-存到真正使用到的子组件中"><a href="#尽可能将-state-存到真正使用到的子组件中" class="headerlink" title="尽可能将 state 存到真正使用到的子组件中"></a>尽可能将 state 存到真正使用到的子组件中</h3><p>将状态放在祖先组件中，通过一层层的 <code>props.xx</code> 和 <code>props.onXXChange</code> 不但开发体验糟糕，还会导致无意义且无法避免的不相关的组件重新渲染。</p><p>如果真的是很多地方使用到的状态，可以放在 <code>redux</code> 中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在我们的应用中有一个存储在 Redux 中的全局状态机，保存着整个应用的核心状态，其类型大概如下：&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; FSMStatus &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Unknown = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Active = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Inactive = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; FSM &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    global_id: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 状态机实例的全局唯一 ID&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    timestamp: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 当前时间，每隔一秒会变化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fsm_status: FSMStatus; &lt;span class=&quot;comment&quot;&gt;// 整个状态机的状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x_mod_status: FSMStatus; &lt;span class=&quot;comment&quot;&gt;// x 模块的状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x_mod_data: &lt;span class=&quot;built_in&quot;&gt;any&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// x 模块的核心数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    y_mod_status: FSMStatus; &lt;span class=&quot;comment&quot;&gt;// y 模块的状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    y_mod_data: &lt;span class=&quot;built_in&quot;&gt;any&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// y 模块的核心数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;还有一些 React 组件，其中 &lt;code&gt;Main&lt;/code&gt; 组件包含了 &lt;code&gt;Inner&lt;/code&gt; 组件，&lt;code&gt;Inner&lt;/code&gt; 组件中使用了 &lt;code&gt;rc-tooltip&lt;/code&gt; 实现了弹窗效果。弹窗中有一个列表，列表中有一条带有特殊样式的处于激活状态的数据，且可以通过按键操作切换处于激活状态的数据项。  &lt;/p&gt;
&lt;p&gt;某天突然用户报告说操作弹窗列表时感到卡顿，而且在弹窗开着的时候其他模块会明显感觉比较卡。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.daraw.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="https://blog.daraw.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Thrift RPC Mock 方案探索</title>
    <link href="https://blog.daraw.cn/2019/06/12/thrift-rpc-mock/"/>
    <id>https://blog.daraw.cn/2019/06/12/thrift-rpc-mock/</id>
    <published>2019-06-12T11:53:00.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景分析"><a href="#背景分析" class="headerlink" title="背景分析"></a>背景分析</h2><p>在传统前后端分离开发的场景下，前端和后端一般定好 HTTP API 接口后就各自进行开发，前端开发中使用 EasyMock、webpack-api-mock 等平台/工具进行接口的 mock，后端通过 Postman / curl 等工具进行接口的自测。</p><p>在微服务场景下，各服务之间通过 IDL 定义好 RPC 接口。但是接口调用方依然有 mock 接口的需求，接口提供方也有着自测接口的需求。公司内的服务化平台已经提供了较为完善的接口测试工具，自己实现一个相对也比较容易，但目前却没有一个比较完善的 RPC Mock 方案。</p><p>在新项目启动后，前端、API 层和依赖的 Service 往往同步开始开发，只要依赖的 Service 未提供，API 和前端的开发、自测都会被阻塞，在侧重数据展示类需求的项目中这种问题更加严重。</p><p>所以，有必要尝试探索一套 RPC Mock 的方案，在保证开发者使用体验的前提下，解决上述问题。</p><a id="more"></a><h2 id="方案调研"><a href="#方案调研" class="headerlink" title="方案调研"></a>方案调研</h2><p>虽然我们的目标和常见的 HTTP API Mock 不一样，但是在设计思路上，RPC Mock 与 HTTP API Mock 其实没有本质的区别，因此我们将传统的 HTTP API Mock 方案也纳入调研范围内。</p><h3 id="Mock-js"><a href="#Mock-js" class="headerlink" title="Mock.js"></a><a href="http://mockjs.com" target="_blank" rel="noopener">Mock.js</a></h3><p>Mockjs 侧重 Mock 数据的生成，自定义了一套描述数据的 DSL，可以生成较为真实的 Mock 数据。<br>另外 Mockjs 还通过在开发本地劫持了 XHR 对象，提供了简单的 HTTP API Mock 的功能。</p><h3 id="EasyMock"><a href="#EasyMock" class="headerlink" title="EasyMock"></a><a href="https://easy-mock.com/" target="_blank" rel="noopener">EasyMock</a></h3><p>Easy Mock 属于 HTTP API Mock。<br>在数据生成方面，需要用户自己编辑接口信息以及 Response 结构体，引入了 Mockjs，使用 Mockjs 的语法描述 Response 结构体以实现生成随机数据，平台服务端还提供了 HTTP 接口服务可供调用。</p><h3 id="mocker-api"><a href="#mocker-api" class="headerlink" title="mocker-api"></a><a href="https://www.npmjs.com/package/mocker-api" target="_blank" rel="noopener">mocker-api</a></h3><p>同上属于 HTTP API Mock，前身为 <a href="https://www.npmjs.com/package/webpack-api-mocker" target="_blank" rel="noopener">webpack-api-mocker</a>。<br>在数据生成方面，用户可以从方法的维度配置固定的 Mock 数据或者配置数据生产函数，并在开发本地起了一个 HTTP Server，将本地开发的请求代理到了这个 Server 上。</p><h3 id="lushijie-thrift-mock"><a href="#lushijie-thrift-mock" class="headerlink" title="lushijie/thrift-mock"></a><a href="https://github.com/lushijie/thrift-mock/" target="_blank" rel="noopener">lushijie/thrift-mock</a></h3><p>只有 Mock Data 的部分，根据 Thrift 的字段与类型信息自动生成 Mock 数据。</p><h3 id="adispring-thrift-mock"><a href="#adispring-thrift-mock" class="headerlink" title="adispring/thrift-mock"></a><a href="https://github.com/adispring/thrift-mock" target="_blank" rel="noopener">adispring/thrift-mock</a></h3><p>只有 Mock Data 的部分，和上面的类似，可以进行二次修改生成的数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 HTTP API 方面，由于协议之类的是非常通用的，所以已经有不少比较成熟的方案，而 RPC 由于各家公司的技术架构不一样，目前没有什么比较成熟的通用方案，而目前公司内也没有这方面的方案。</p><p>借鉴比较成熟的那些 HTTP API Mock 方案，基本可以确定我们的思路，方案整体分为两部分：Mock 请求 + Mock 数据。首先我们需要搭建一个能够和正常服务一样可被调用的 Mock 服务，接着在调用时返回 Mock 数据。</p><h2 id="方案设计-V1（CLI）"><a href="#方案设计-V1（CLI）" class="headerlink" title="方案设计 V1（CLI）"></a>方案设计 V1（CLI）</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>上述方案中最成熟的应该是 EasyMock，受其影响，第一反应是做成类似的样子，开发一个平台，开发者在平台上配置 Mock 数据，平台提供可被调用的 Mock RPC Server。但是由于 Thrift RPC 协议的特殊性，无法简单的在一个 IP:PORT 下部署多个服务，所以平台化提供可被调用的 Mock 服务不太可能实现。</p><p>既然无法做到类似 EasyMock 那样，那退一步和 mocker-api 那样在开发本地起一个 RPC Mock Server 肯定是没有问题的，例如把 RPC Mock Server 起在了本地的 8888 端口，业务中想要调用本地的服务而不是真实的服务时，只需要将 RPC Client 配置中的 Service Name（服务发现使用了 Consul ）改为写死的 IP:PORT 127.0.0.1:8888 即可。</p><p>于是，第一版方案的思路大致如下：<br>初版方案的设想是做成类似 mocker-api 的 CLI。CLI 想要在本地启动 RPC Server，则必须要有的三个信息：Service Name、Thrift 文件位置以及服务端口，另外还需要为用户提供可选的类似 mocker-api 的配置 Mock 数据的入口。</p><p>有了上面的基本信息后，就足以起一个 RPC Server 了，接下来是 Mock 数据生成的工作。生成 Mock 数据主要有两个思路，自动生成与用户配置。</p><ol><li>自动生成数据：已经有 Thrift IDL 文件的情况下，可以 parse thrift 文件得到数据结构字段和类型等信息，并根据类型信息使用 Mockjs 构造随机数据。</li><li>用户配置数据：Mock 数据配置文件的书写方式和 mocker-api 也很相似，提供一个 <code>commonjs</code> 文件，默认输出的对象是 key 为方法名，value 是对象或者是函数。例如我们需要配置 ID 生成器服务 <code>IDGenService</code> 的 <code>Gen</code> 方法：</li></ol><ul><li>当使用固定对象时，每次返回的都是配置的 Response。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDGenService</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    Gen: &#123;</span><br><span class="line">        Id: <span class="string">"123456"</span>,</span><br><span class="line">        Extra: &#123;</span><br><span class="line">            Message: <span class="string">"success"</span>,</span><br><span class="line">            Code: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>如上在调用 <code>rpc.IDGenService.Gen(req)</code> 时，返回的永远是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Id: <span class="string">"123456"</span>,</span><br><span class="line">    Extra: &#123;</span><br><span class="line">        Message: <span class="string">"success"</span>,</span><br><span class="line">        Code: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有时候我们想配置一些简单的规则，以避免固定对象导致业务逻辑冲突：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDGenService</span></span><br><span class="line"><span class="keyword">let</span> globalId = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    Gen: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">        Id: <span class="string">`<span class="subst">$&#123;globalId++&#125;</span>`</span>,</span><br><span class="line">        Extra: &#123;</span><br><span class="line">            Message: <span class="string">'success'</span>,</span><br><span class="line">            Code: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>如上在调用 <code>rpc.IDGenService.Gen(req)</code> 时，返回的 <code>Id</code> 每次都会递增：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Id: <span class="string">"100"</span>, <span class="comment">// 101, 102, 103, ...</span></span><br><span class="line">    Extra: &#123;</span><br><span class="line">        Message: <span class="string">"success"</span>,</span><br><span class="line">        Code: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，用户启动 CLI 后，CLI 会在本地起一个 RPC Server，收到调用请求后，如果用户为该方法配置了 Mock 数据，则返回配置好的 Mock 数据，否则根据 Thrift 文件的类型信息动态构造出 Mock Response 内容。</p><p><img src="//sf1-ttcdn-tos.pstatp.com/obj/ttfe/ev/4d42f7aa78192ebab572cbe468e984b9.png" alt="CLI 处理流程"></p><h3 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h3><p>在确定方案后，很快开发出了基本可用的版本，由于和公司内基础设施耦合比较严重，这里不放出相关实现。</p><h3 id="方案总结"><a href="#方案总结" class="headerlink" title="方案总结"></a>方案总结</h3><p>在最近的两个项目中使用了上面的 CLI，基本能满足业务开发中的 RPC Mock 需求，但是抛开 TODO 中未实现功能点（例如 HotReload）外，发现了一些问题：</p><p><strong>不能控制方法级别的 Mock</strong><br>比如 <code>IDGenService</code> 有两个方法 <code>Gen</code> 和 <code>GenMulti</code>，我只想 Mock <code>Gen</code> 方法，不想 Mock <code>GenMulti</code> 方法，在这种方式下没有比较简单的实现方式。</p><p><strong>自动 Mock 数据基本不可用</strong><br>直接把 Thrift 中的类型信息转为 Mockjs 的配置会存在下面两个问题，从而导致数据基本不可用：</p><ol><li>可选项的处理<br>可选项存在两种情况：</li></ol><ul><li>业务意义上的选填，这种可选可不选，构造 Mock 数据的时候可以随机填写；</li><li>迭代过程中添加的字段，遵循 Thrift 的最佳实践，为了保证线上服务的正常运行，新增的字段应该选为可选项，但是在业务上是必选的，如果不选可能会报错，而我们在构造 Mock 数据的时候是不知道到底是不是该必选。</li></ul><ol start="2"><li>Mock 数据的真实性<br>很多字段是有约定或者有业务意义的，例如 <code>Code</code>、<code>Name</code>、<code>ID</code> 等等，不能直接按照 <code>int</code> <code>string</code> 等类型信息构造 mock 数据。轻则只影响展示效果，重则导致逻辑错误（例如生成一个不存在的 <code>Code</code>、负数的时长等等）。</li></ol><p><strong>CLI 形式不够友好</strong>  </p><ol><li>如果需要同时配置 N 个 Service 的 Mock，那就需要打开 N 个 Terminal Tab 并使用 CLI 起 N 个 Mock Server。</li><li>提交代码的时候得注意不能把写死的临时配置代码带上去。</li></ol><p><strong>语言无关</strong><br>当然，这个 CLI 也有一定的优点，也是 Thrift RPC 协议的优点：他是语言无关的。无论你在开发的业务使用的什么语言和框架，都可以使用。</p><p>针对上面发现的一系列问题，首先决定暂时先放弃数据的自动化生成，只支持用户自行配置数据的方式；另外和 Mentor 沟通后，他提醒我一点，既然在 Node.js 项目中，RPC Middleware 是把 RPC Client 对象挂到了 <code>ctx</code> 上（这里是 Koa，在 Express 中是挂到了 <code>req</code> 上），那么完全可以通过中间件的形式再把 <code>ctx.rpc</code> 劫持了，在 Node.js 项目中做到更简单的实现、更精细的粒度控制和更好的使用体验。</p><p>于是，有了下面的 V2 版本的方案设计。</p><h2 id="方案设计-V2（Middleware）"><a href="#方案设计-V2（Middleware）" class="headerlink" title="方案设计 V2（Middleware）"></a>方案设计 V2（Middleware）</h2><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>由于方案 V2 中选择通过劫持 <code>ctx.rpc</code> 对象上的 <code>xService.yMethod</code> 函数实现 Mock，和 Mockjs 劫持 XHR 思路很相似，所以不再需要在本地启动 RPC Server，而且可以轻松同时配置多个 Service 的 Mock，方案 V1 中启动 RPC Server 必要的三个信息（Service Name、Thrift File、Server Port）也不再需要，开发者使用时只需要提供一个 Mock 数据配置文件即可。</p><p>在配置文件中，配置需要 Mock 的 Service 和方法，以及方法对应的 Mock 数据 / 数据生成函数（和 V1 相似），配置文件中暴露出来的对象的类型如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Mock &#123;</span><br><span class="line">    [serviceName: <span class="built_in">string</span>]: &#123;</span><br><span class="line">        [methodName: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// object | Function</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比 V1 中的配置方式，只是加了一个层级用于配置 Service，以便同时做到多 Service 支持。</p><h3 id="方案实现-1"><a href="#方案实现-1" class="headerlink" title="方案实现"></a>方案实现</h3><p>同上，和内部基础设施耦合，不放出相关具体实现。<br>使用时只需要在 rpc 中间件之后再添加 mock 中间件即可，对于业务代码的入侵极低。另外可以加一下环境的判断，只有在开发环境才会使用 mock 中间件。</p><p>要注意的是，由于需要劫持 ctx.rpc，所以必须要在 rpc 中间件之后使用 mock 中间件，否则 mock 不会生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockConfig = path.resolve(__dirname, <span class="string">'mock/mock.config.js'</span>);</span><br><span class="line"><span class="comment">// 一定要在 rpc 中间件之后引入 mock 中间件</span></span><br><span class="line">app.use(rpc(rpcConfig));</span><br><span class="line">app.use(mock(mockConfig));</span><br></pre></td></tr></table></figure><p>其中只有配置了 Mock 的 Service 的 Method 才会生效。例如 <code>IDGenService</code> 有 <code>Gen</code> 和 <code>GenMulti</code> 两个方法，如果我们配置了其他 Service 但是没有配置 <code>IDGenService</code>，那么 <code>IDGenService</code> 上的 RPC 方法被调用时会直接请求真实的服务；如果只配置了 <code>IDGenService</code> 的 <code>Gen</code> 方法，那么在调用 <code>ctx.rpc.IDGenService.Gen</code> 会命中 Mock，而 <code>ctx.rpc.IDGenService.GenMulti</code> 依然会请求真实的服务。即可以做到 Service + Method 粒度的配置。</p><p>在中间件中其实是做了两层嵌套循环：遍历 <code>ctx.rpc</code> 对象上的所有 Service，如果在配置文件中命中了该 Service，则对该 Service 对象再做一次遍历，遍历其上的所有 Method，如果在配置文件中命中了 Method，才会劫持该 Method。实现其实很简单，理解了实现也就理解了上面配置的 Service + Method 的粒度控制。</p><p>另外在实际使用中，建议在项目代码目录下添加一个 mock 文件夹，将配置文件放到该文件夹下，并将该文件夹添加到 nodemon 等监听文件修改热重载工具的监听范围内，这样在配置文件更新后也能获得热重载的能力，并且团队内可以共用 Mock 数据。</p><h3 id="方案总结-1"><a href="#方案总结-1" class="headerlink" title="方案总结"></a>方案总结</h3><p>V2 中间件的方案更多的是解决了 Node.js 项目的 Mock 实现方式，但我们还有其他方面需要优化：  </p><p><strong>Mock 数据构造</strong><br>IDL 中的字段名字、类型是有用的，利用好是可以减少 Mock 数据的构造成本的。但是这块如何做好后续依然需要探索，目前手动构造的方案虽然需要成本，但是也是可以接受的。</p><p><strong>跨语言/框架支持</strong><br>相比 V1 CLI 的形式，V2 中间件的形式目前只支持 Nodejs 的 Koa / Express 框架，但是 Mock 的需求是普遍存在的。由于 JS 动态语言的特点，所以劫持变量可以很简单的实现 Nodejs 项目的 Mock Middleware，如何做其他语言 / 框架的支持，后续依然值得探索。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景分析&quot;&gt;&lt;a href=&quot;#背景分析&quot; class=&quot;headerlink&quot; title=&quot;背景分析&quot;&gt;&lt;/a&gt;背景分析&lt;/h2&gt;&lt;p&gt;在传统前后端分离开发的场景下，前端和后端一般定好 HTTP API 接口后就各自进行开发，前端开发中使用 EasyMock、webpack-api-mock 等平台/工具进行接口的 mock，后端通过 Postman / curl 等工具进行接口的自测。&lt;/p&gt;
&lt;p&gt;在微服务场景下，各服务之间通过 IDL 定义好 RPC 接口。但是接口调用方依然有 mock 接口的需求，接口提供方也有着自测接口的需求。公司内的服务化平台已经提供了较为完善的接口测试工具，自己实现一个相对也比较容易，但目前却没有一个比较完善的 RPC Mock 方案。&lt;/p&gt;
&lt;p&gt;在新项目启动后，前端、API 层和依赖的 Service 往往同步开始开发，只要依赖的 Service 未提供，API 和前端的开发、自测都会被阻塞，在侧重数据展示类需求的项目中这种问题更加严重。&lt;/p&gt;
&lt;p&gt;所以，有必要尝试探索一套 RPC Mock 的方案，在保证开发者使用体验的前提下，解决上述问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="服务端" scheme="https://blog.daraw.cn/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
      <category term="RPC" scheme="https://blog.daraw.cn/tags/RPC/"/>
    
      <category term="Thrift" scheme="https://blog.daraw.cn/tags/Thrift/"/>
    
      <category term="Mock" scheme="https://blog.daraw.cn/tags/Mock/"/>
    
      <category term="Node.js" scheme="https://blog.daraw.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>前端视频质量监控</title>
    <link href="https://blog.daraw.cn/2018/09/07/video-quality-monitor/"/>
    <id>https://blog.daraw.cn/2018/09/07/video-quality-monitor/</id>
    <published>2018-09-07T00:10:00.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>业务中使用到视频播放后，一些不确定的因素例如用户端网络异常、CDN 异常等等，导致视频加载缓慢和发生卡顿，这些质量问题会给用户体验带来较大的伤害，也会影响产品的留存转化率。因此对线上视频进行质量监控意义很大，可以让我们明确知道用户端的异常发生概率，以便做进一步的优化。</p><a id="more"></a><p>在我们的业务中，是不支持用户自己控制视频播放/暂停以及播放进度的，所以我们不需要考虑一些用户控制的边界情况；另外一部分视频会在挂载到真实 DOM 前做预加载（preload）处理，因此我们要留意下这类视频和无预加载的视频的差异。<br>另外我们的业务只在 PC 上，而且用户使用的都是现代浏览器（Chrome 为主），所以不需要考虑移动端的兼容性以及老浏览器的兼容性。</p><h2 id="思路与实现"><a href="#思路与实现" class="headerlink" title="思路与实现"></a>思路与实现</h2><p><code>video</code> Element 在播放视频的过程中会触发一系列的媒体事件（Media events），通过查阅 MDN Media events 列表，可以发现值得关注的几个事件分别是 <code>canplay</code> <code>canplaythrough</code> <code>error</code> <code>loadeddata</code> <code>loadedmetadata</code> <code>loadstart</code> <code>play</code> <code>playing</code> <code>waiting</code>。  </p><p>首先 <code>error</code> 事件可以不用特别关注，和常规错误监控一样处理即可；重点在于如何统计加载耗时及卡顿现象。  </p><p>接下来我们拿一个视频简单做下试验，看下这几个事件触发的时机以及先后顺序。<br><strong>测试环境：macOS 10.13.6 / Chrome 68</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'loadstart'</span>, <span class="string">'loadedmetadata'</span>, <span class="string">'loadeddata'</span>, <span class="string">'waiting'</span>, <span class="string">'canplay'</span>, <span class="string">'canplaythrough'</span>, <span class="string">'error'</span>, <span class="string">'play'</span>, <span class="string">'playing'</span>, <span class="string">'ended'</span>].forEach(<span class="function">(<span class="params">eventName</span>) =&gt;</span> &#123;</span><br><span class="line">  video.addEventListener(eventName, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">`_<span class="subst">$&#123;eventName&#125;</span>_time`</span>;</span><br><span class="line">    video[key] = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(eventName, <span class="built_in">Date</span>.now());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于一个无预加载的视频来说，从开始加载到正常播放，输出日志为：</p><table><thead><tr><th>event</th><th>time</th><th>cost</th></tr></thead><tbody><tr><td>play</td><td>1536561748438</td><td>0</td></tr><tr><td>waiting</td><td>1536561748438</td><td>0</td></tr><tr><td>loadstart</td><td>1536561748455</td><td>17</td></tr><tr><td>loadedmetadata</td><td>1536561748588</td><td>133</td></tr><tr><td>loadeddata</td><td>1536561748613</td><td>25</td></tr><tr><td>canplay</td><td>1536561748621</td><td>8</td></tr><tr><td>playing</td><td>1536561748625</td><td>4</td></tr><tr><td>canplaythrough</td><td>1536561748627</td><td>2</td></tr></tbody></table><p>对于一个有预加载处理的视频来说，对应的输出日志为：</p><table><thead><tr><th>event</th><th>time</th><th>cost(ms)</th></tr></thead><tbody><tr><td>loadstart</td><td>1536562506189</td><td>0</td></tr><tr><td>loadedmetadata</td><td>1536562506271</td><td>82</td></tr><tr><td>loadeddata</td><td>1536562506304</td><td>33</td></tr><tr><td>canplay</td><td>1536562506305</td><td>1</td></tr><tr><td>canplaythrough</td><td>1536562506307</td><td>2</td></tr><tr><td>play</td><td>1536562526391</td><td>20084</td></tr><tr><td>playing</td><td>1536562526392</td><td>1</td></tr></tbody></table><p>观察上述事件触发的顺序，对应 MDN 上对事件的描述，与视频初始化相关的几个事件 <code>loadstart</code> <code>loadedmetadata</code> <code>loadeddata</code> 在视频加载的时候会依次触发，分别代表着开始加载、元信息加载成功、首帧加载成功，因此在统计视频加载延迟的时候，我们基本可以确定统计这三个事件触发的时间差即为加载延迟。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logLatency = <span class="function">(<span class="params">video</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (video._loadstart_time &amp;&amp; video._loadedmetadata_time &amp;&amp; video._loadeddata_time) &#123;</span><br><span class="line">    <span class="keyword">const</span> loadedmetadataCost = video._loadedmetadata_time - video._loadstart_time;</span><br><span class="line">    <span class="keyword">const</span> loadeddataCost = video._loadeddata_time - video._loadstart_time;</span><br><span class="line"></span><br><span class="line">    logger.log(<span class="string">'Latency'</span>, [loadedmetadataCost, loadeddataCost]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="string">'loadstart'</span>, <span class="string">'loadedmetadata'</span>, <span class="string">'loadeddata'</span>].forEach(<span class="function">(<span class="params">eventName</span>) =&gt;</span> &#123;</span><br><span class="line">  video.addEventListener(eventName, <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">`_<span class="subst">$&#123;eventName&#125;</span>_time`</span>;</span><br><span class="line">    video[key] = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 loadeddata 时记录延迟</span></span><br><span class="line">    <span class="keyword">if</span> (eventName === <span class="string">'loadeddata'</span>) &#123;</span><br><span class="line">      logLatency(video);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟只需记录一次，相关的监听器触发过后则可移除</span></span><br><span class="line">    video.removeEventListener(eventName, callback);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来我们在播放过程中用 Chrome Dev Tool 的 Network 模拟弱网（网络抖动），输出日志为：</p><table><thead><tr><th>event</th><th>time</th><th>cost(ms)</th></tr></thead><tbody><tr><td>waiting</td><td>1536565784729</td><td>0</td></tr><tr><td>canplay</td><td>1536565785075</td><td>346</td></tr><tr><td>playing</td><td>1536565785076</td><td>1</td></tr></tbody></table><p>观察上述事件触发的顺序，对应 MDN 上对事件的描述，与视频初始化相关的几个事件 <code>waiting</code> <code>canplay</code> <code>playing</code> 在视频播放过程中发生卡顿到再次播放的时候会依次触发，分别代表着等待、加载了足够的数据可以播放、<code>play</code> 事件后有足够多的数据可以开始播放或者从卡顿缓冲中恢复过来。在统计视频卡顿的时候，我们基本从这三个事件入手。  </p><p>对比初次加载时的事件触发顺序，可以不用关注 <code>canplay</code> 事件，只关注 <code>waiting</code> 和 <code>playing</code>，但是这里又有一个问题就是无预加载的视频在刚开始播放时会触发 <code>waiting</code> 和 <code>playing</code>，预加载的视频在刚开始播放时只会触发 <code>playing</code>，所以我们要忽略掉第一次 <code>playing</code> 事件，从第二次开始记录 <code>waiting</code> 和 <code>playing</code> 的时间差，即为卡顿时长（卡顿缓冲耗时）。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logBuffer = <span class="function">(<span class="params">video</span>) =&gt;</span> &#123;</span><br><span class="line">  video._buffer_times += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初次缓冲为正常缓冲，不上报</span></span><br><span class="line">  <span class="keyword">if</span> (video._buffer_times === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (video._waiting_time &amp;&amp; video._playing_time) &#123;</span><br><span class="line">    <span class="keyword">const</span> bufferCost = video._playing_time - video._waiting_time;</span><br><span class="line">    logger.log(<span class="string">'Buffer'</span>, [bufferCost]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">video._buffer_times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">[<span class="string">'waiting'</span>, <span class="string">'playing'</span>, <span class="string">'ended'</span>].forEach(<span class="function">(<span class="params">eventName</span>) =&gt;</span> &#123;</span><br><span class="line">  video.addEventListener(eventName, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">`_<span class="subst">$&#123;eventName&#125;</span>_time`</span>;</span><br><span class="line">    video[key] = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 playing 时记录卡顿</span></span><br><span class="line">    <span class="keyword">if</span> (eventName === <span class="string">'playing'</span>) &#123;</span><br><span class="line">      logBuffer(video);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 播放结束重置卡顿计数器</span></span><br><span class="line">    <span class="keyword">if</span> (eventName === <span class="string">'ended'</span>) &#123;</span><br><span class="line">      video._buffer_times = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意在视频播放结束的时候，我们要把 <code>_buffer_times</code> 计数器重置为 0，否则在该视频二次播放的时候，初次加载就被认为是卡顿。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>当卡顿超过一定时长时（暂定 1 秒），用户可能会失去耐心关闭页面或者刷新页面，如果我们一味的等待视频缓冲完再统计，可能会丢失这种情况的数据。另外实际上当卡顿时间超过忍耐时长后，再统计具体的时间已经没有太大意义了。因此我们可以对上面的方案进行优化，增加卡顿超时直接统计的逻辑。  </p><p>原理也很简单，在 <code>waiting</code> 时设置一个定时器与 <code>playing</code> 监听器回调竞争：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BufferTimeout = <span class="number">1000</span>; <span class="comment">// 卡顿超时阈值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logBuffer = <span class="function">(<span class="params">video, timeout</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (video._buffer_reported) &#123;</span><br><span class="line">    video._buffer_reported = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  video._buffer_times += <span class="number">1</span>;</span><br><span class="line">  video._buffer_reported = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初次缓冲为正常缓冲，不上报</span></span><br><span class="line">  <span class="keyword">if</span> (video._buffer_times === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超时上报</span></span><br><span class="line">  <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">    logger.log(<span class="string">'Buffer '</span>, [BufferTimeout]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正常上报</span></span><br><span class="line">  <span class="keyword">if</span> (video._waiting_time &amp;&amp; video._playing_time) &#123;</span><br><span class="line">    <span class="keyword">const</span> bufferCost = video._playing_time - video._waiting_time;</span><br><span class="line">    logger.log(<span class="string">'Buffer'</span>, [bufferCost]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">video._buffer_times = <span class="number">0</span>;</span><br><span class="line">video._buffer_reported = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">[<span class="string">'waiting'</span>, <span class="string">'playing'</span>, <span class="string">'ended'</span>].forEach(<span class="function">(<span class="params">eventName</span>) =&gt;</span> &#123;</span><br><span class="line">  video.addEventListener(eventName, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">`_<span class="subst">$&#123;eventName&#125;</span>_time`</span>;</span><br><span class="line">    video[key] = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载超时直接记录</span></span><br><span class="line">    <span class="keyword">if</span> (eventName === <span class="string">'waiting'</span>) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        logBuffer(video, <span class="literal">true</span>);</span><br><span class="line">      &#125;, BufferTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 playing 时记录卡顿</span></span><br><span class="line">    <span class="keyword">if</span> (eventName === <span class="string">'playing'</span>) &#123;</span><br><span class="line">      logBuffer(video);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 播放结束重置卡顿计数器</span></span><br><span class="line">    <span class="keyword">if</span> (eventName === <span class="string">'ended'</span>) &#123;</span><br><span class="line">      video._buffer_times = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实这里的超时逻辑还可以用 <code>Promise.race</code> 来实现，不过现在这样通过 Flag 来控制竞态也是没啥问题的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events" target="_blank" rel="noopener">Media events - MDN</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;业务中使用到视频播放后，一些不确定的因素例如用户端网络异常、CDN 异常等等，导致视频加载缓慢和发生卡顿，这些质量问题会给用户体验带来较大的伤害，也会影响产品的留存转化率。因此对线上视频进行质量监控意义很大，可以让我们明确知道用户端的异常发生概率，以便做进一步的优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.daraw.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="视频" scheme="https://blog.daraw.cn/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="质量监控" scheme="https://blog.daraw.cn/tags/%E8%B4%A8%E9%87%8F%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>前端函数式编程</title>
    <link href="https://blog.daraw.cn/2017/08/16/fp-with-fe/"/>
    <id>https://blog.daraw.cn/2017/08/16/fp-with-fe/</id>
    <published>2017-08-16T22:19:15.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<p>前言：这个其实是我最近打算在在团队做的一个分享，这个分享将会聊聊函数式编程在前端的一些成熟的应用以及尝试。</p><a id="more"></a><h2 id="Something-interesting"><a href="#Something-interesting" class="headerlink" title="Something interesting"></a>Something interesting</h2><h3 id="罗素悖论"><a href="#罗素悖论" class="headerlink" title="罗素悖论"></a>罗素悖论</h3><p>在讲罗素悖论之前，先提一个小的需求，看看大家能不能实现：</p><blockquote><p>设计出一个函数<code>f</code>，接受一个函数<code>g</code>作为参数，返回布尔值。<br>函数<code>f</code>判断<code>g</code>会不会导致死循环，会则返回<code>true</code>，不会则返回false。</p></blockquote><p>如果学过离散数学的同学可能就会想起来了，这便是著名的<strong>图灵机停机问题</strong>。这个需求看似描述很完备，有输入输出的要求，也有函数功能的要求，但这个需求是不可实现的。<br>证明很简单：假设存在满足上述要求的函数<code>f</code>，那么我们定义一个邪恶的函数<code>evil</code>，其伪代码定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evil</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f(evil) == <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是这里便产生了悖论：如果<code>f</code>判定<code>evil</code>不会死循环，<code>evil</code>就会死循环；反之则不会死循环。所以假设不成立，即不存在符合要求的<code>f</code>。  </p><p>类似的悖论还有著名的理发师悖论：理发师给所有不给自己理发的人理发。<br>不可解的<code>停机问题</code>其实便是<strong>哥德尔不完备定理</strong>的一种形式。</p><h3 id="Lambda-λ-演算"><a href="#Lambda-λ-演算" class="headerlink" title="Lambda (λ) 演算"></a>Lambda (λ) 演算</h3><blockquote><p>Lambda演算可以被称为最小的通用程序设计语言。它包括一条变换规则（变量替换）和一条函数定义方式，Lambda演算之通用在于，任何一个可计算函数都能用这种形式来表达和求值。因而，它是等价于图灵机的。尽管如此，Lambda演算强调的是变换规则的运用，而非实现它们的具体机器。可以认为这是一种更接近软件而非硬件的方式。 –from Wikipedia</p></blockquote><p>这里我不会去讲太多关于Lambda演算的内容，一个原因是在没有一些相关的数理逻辑的前置知识的前提下很难三言两语之内将其描述清楚，另一个原因是我自己也不是很懂（笑。  </p><p>那么为什么会提到Lambda演算呢？在图灵机的停机问题之前，有一个更加有趣的问题：能否判断两个lambda演算表达式是否等价，这个问题和图灵机停机问题同属于判定性问题。邱奇运用λ演算在1936年给出判定性问题一个否定的答案。<br>最重要的，Lambda演算对函数式编程语言有巨大的影响，比如Lisp语言、ML语言和Haskell语言。而通过这些，我们将引入今天的主要话题：函数式编程。但是注意的是，今天我讲的将会是偏前端方向的应用，而不会去过度的探讨演算、或者是范畴论等知识。</p><h2 id="语言层面"><a href="#语言层面" class="headerlink" title="语言层面"></a>语言层面</h2><p>首先放出我的观点：<strong>JavaScriprt 适合也不适合函数式编程</strong>。</p><h3 id="适合函数式编程"><a href="#适合函数式编程" class="headerlink" title="适合函数式编程"></a>适合函数式编程</h3><p>JavaScript是一门多范式的语言，我们很难去说JS到底是面向过程还是面向对象的语言，甚至我们也可以说JS就是一门函数式语言。但是这一切并不是矛盾的，OOP与FP完全可以结合起来使用。  </p><p>对于函数式语言的定义其实没有明确的界限，没有说一定要有Monad，或者是Hindley-Milner类型系统等等。JS中函数是一等对象，所以完全可以认为JS是一门函数式编程语言，而且JS的灵活性允许我们去模拟常见函数式语言中的大多数操作。</p><ul><li><p>纯函数 无副作用</p><blockquote><p>此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关。<br>该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。</p></blockquote></li><li><p>不可变数据</p><blockquote><p>Immutable Data是指一旦被创造后，就不可以被改变的数据。</p></blockquote><p>也许大家会产生疑惑，没有变量应用怎么跑起来？这里注意的是虽然没有变量，但是会有绑定的概念，数据虽然不可变，但是绑定可变。  </p><p>JS本身提供了一个<code>Object.freeze()</code>方法，但是类似浅拷贝，它只是一层浅<code>freeze</code>，所以如果真的要去<code>freeze</code>一个对象，必须一层层递归<code>freeze</code>处理。  </p><p>这样做虽然可以实现不可变，但是无论做不做<code>freeze</code>处理，每次都产生一个新的对象会带来大量的中间变量，这一点后面我讲到Redux的时候也会提到，如果使用过Redux，相信应该知道这个问题，<code>Object.assign</code>会带来大量的中间对象，影响性能，而解决方案就是Immutable.js。<br>Immutable.js是一个不可变数据结构的JS库，它的原理其实也很简单，借助字典树，共享了不变的部分。有兴趣的同学可以读一读一篇著名的文章《Understanding Clojure’s Persistent Vectors》，Immutable.js的实现原理与Clojure的数据结构底层实现非常相似。下面的Redux环节我还会提到这个问题。</p></li><li><p>递归<br>循环和循环是常见的流程控制方式，在绝大多数场景下两者是可以等价互换的。<br>递归的优点在于代码简洁、清晰，并且容易验证正确性。在一些函数式语言中，即使存在流程控制语句<code>if</code> <code>else</code>等等，他们也只是函数的语法糖。  </p></li><li><p>curry / compose / …<br>这些虽然JS没有直接提供，但是已经有足够多的第三方库可以来做这个工作，例如 Underscore / Lodash / Ramda。这些函数的实现也可以阅读上述库的源码来学习。</p></li><li><p>惰性求值<br>惰性求值可以最小化计算机要做的工作。JS中有着一小部分表达式是属于惰性求值的，例如<code>||</code>和<code>&amp;&amp;</code>，这也是所谓的“短路原理”：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line"><span class="literal">true</span> || i++</span><br><span class="line"><span class="literal">false</span> &amp;&amp; i++</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但是语言直接提供的这点惰性实在是太可怜了，JS中也基本都是立即求值。<br>这里拿Haskell举个例子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">import</span> Data.List</span><br><span class="line"><span class="type">Prelude</span> <span class="type">Data</span>.<span class="type">List</span>&gt; take <span class="number">10</span> $ sort [<span class="number">100</span>, <span class="number">99.</span><span class="number">.0</span>] :: [<span class="type">Int</span>]</span><br><span class="line"><span class="comment">-- [0,1,2,3,4,5,6,7,8,9]</span></span><br></pre></td></tr></table></figure><p>简单介绍下，<code>[Int]</code>是类型标注，表示返回的是一个整型列表；<code>[100, 99..0]</code>代表生成一个等差的列表；<code>sort</code>是排序；<code>$</code>是一个中缀函数，可以理解为把右边部分括起来。<br>这段代码的意思是生成一个100到0的等差数列，把这个等差列表从小到大排序并取出前十个。如果在JavaScript中的等价的代码应该类似如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">100</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  arr.push(i)</span><br><span class="line">&#125;</span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment">// [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span></span><br></pre></td></tr></table></figure><p>无论是什么JS引擎，这段JS代码在执行的时候都会把这个数组的所有元素都遍历一遍；相反的是上面的Haskell代码在执行的时候，Haskell的编译器GHC只会尝试去计算刚好足够取出需要的10个元素为止。所以，在Haskell中，我们完全可以定义出无限长度的数组，然后设法取出其中的一部分，GHC也会在底层通过一些黑魔法来帮助实现。  </p><p>让我们回到JS：在ES6之前，模拟惰性求值的方式一般是thunk函数，或者借助Stream抽象。所幸ES6使得JS拥有了强大的<code>generator</code>函数，我们现在还可以借助它模拟惰性求值。  </p><p>具体的实现可以阅读参考文献中的文章，也有现成的库例如Lazy.js可以使用，这里不再赘述。  </p><p>但是注意的是，惰性求值可以为我们带来较好的性能，也可以导致性能下降。大量的延迟求值，可能会带来内存的消耗积压。Haskell中这个现象称为任务堆积，所以即便是默认惰性求值的Haskell，也为使用者提供了强制立即求值的方法，有兴趣的同学可以自行学习一些Haskell的知识。</p></li></ul><h3 id="不适合函数式编程"><a href="#不适合函数式编程" class="headerlink" title="不适合函数式编程"></a>不适合函数式编程</h3><ul><li><p>递归<br>在JS中，递归容易导致一个致命的问题：<strong>爆栈</strong>。<br>尾递归优化可以使得尾递归在编译时被优化为循环从而避免爆栈，但是到目前为止，JS是没有什么正儿八经的尾递归优化的，当然我们有着<code>Trampolining</code>这样的奇技淫巧可以巧妙的避免爆栈，但是每一层的转换消耗的匿名函数开销也是不可小觑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = f.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">while</span> (result <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">      result = result();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reduce = trampoline(<span class="function"><span class="keyword">function</span> <span class="title">myself</span>(<span class="params">f, list, sum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (list.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> val = list.shift();</span><br><span class="line">      <span class="keyword">return</span> myself(f, list, f(val, list));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面这段代码来自贺老在今年的FP China会议上的分享STC VS PTC。<br>ES6早已规定了JS应该有尾递归的优化，但是大家迟迟不去实现，主要是尾递归优化的STC与PTC之争：<br>PTC:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n, total = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> total</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> sum(n - <span class="number">1</span>, total + n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PTC目前只有Safari支持，V8可以通过flag开启。STC的问题在于不知道写对了没有，开发时不爆栈不代表生产环境不爆栈，以及很难以调试。<br>STC:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, acc = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">continue</span> factorial(n - <span class="number">1</span>, acc * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>STC通过新的语法，保证不写对就会报错，但是新的语法会引入维护等一些问题。<br>所以因为STC与PTC之争，至今JS仍没有一个可靠的尾递归优化。</p></li><li><p>纯函数难以保证<br>在Haskell、Clojure等语言中，会有语言或者是编译的层面去做纯度的保障，但是在JS中，这一切只能靠我们自己来做约束，在多人合作的时候很难保证不会有坑。</p></li><li><p>弱类型，难以模拟类型系统</p></li><li><p>没有 monadic io</p></li><li><p>。。。</p></li></ul><h2 id="架构层面"><a href="#架构层面" class="headerlink" title="架构层面"></a>架构层面</h2><p>事实上，随着RxJS、React全家桶等受函数式影响的库的崛起，前端可以说是工程里应用函数式最为成熟的领域之一了。目前应用函数式比较广泛的领域还有金融（Haskell、Erlang等等），大数据（Scala）。</p><h3 id="React全家桶"><a href="#React全家桶" class="headerlink" title="React全家桶"></a>React全家桶</h3><p>首先，<strong>这不是一个React全家桶相关的入门介绍文章</strong>，理解接下来的内容期望你至少有一些React的相关开发经验，有一些Redux的开发经验就更棒了！</p><ul><li><p>React<br>先说说React，提及React，大家想到的往往是V-DOM，以至于Vue2在引入V-DOM后，两者已经极其相似了，事实上两者在设计思想上有一个很大的区别，在于React更加追求纯度，Vue的作者尤雨溪也曾明确表示Vue并不像React那样追求纯度。</p><p>相信大家都知道语法糖，这是指简化的语法，鼓励大家使用，例如ES6的Class、Arrow Function等等都是语法糖。那么不知道你有没有思考过，为什么React的生命周期函数的名字那么长？为什么React直接输出HTML的API名字<code>dangerouslySetInnerHTML</code>那么长？<br>这其实是一个很古老的API设计，叫做<strong>语法盐</strong>，与语法糖相反，它设计出让人感觉难用的API，让使用者在使用前多加思考是不是真的需要使用这些API，从而避免写出低质量的代码设计。</p><p>既然React不鼓励使用生命周期函数，那么React鼓励的是什么呢？答案是<strong>Pure Component</strong>。<br>React鼓励你去从一个不变的角度思考组件，如果你的组件无须设定生命周期钩子函数，那么你的组件类可以继承<code>PureComponent</code>而非普通的<code>Component</code>，<code>PureComponent</code>会自动去做<code>shouldComponentUpdate()</code>的判断优化。<br>但是<code>PureComponent</code>并非万能的灵药，先抛去其浅对比（shallowly compare）<code>state / prop</code>的缺陷不谈，一个应用怎么可能避免不了状态呢？React并不管，它只管给定状态就能做到幂等渲染，虽然保证了自身的纯度，却把状态的问题抛回给了用户。</p></li><li><p>Redux<br>这是社区对React应用的数据层解决方案。这里我也不会去讲Flux架构入门基础，更不会去讲其被讲烂了的Pub/Sub设计模式。</p><p>接触过Redux的一定会对Redux中反复提及<code>reducer</code>纯函数、<code>state</code>不可变等函数式的概念印象深刻；如果读过Redux的源码，你会发现Redux内部通过<code>compose</code>以极低的代码成本实现了洋葱模型的中间件。</p><p>除去这些函数式风格的API，和函数式的实现，更重要的是Redux实现了一套CQRS + ES软件架构。<br>CQRS全称Command Query Responsibility Segregation，即命令查询职责分离；ES全称Event Sourcing，即事件溯源。为什么会提CQRS + ES架构呢？因为目前为止，可以看到的基于函数式的大型项目至少一半都是基于这套架构，</p><p>下面我简单的讲一下这一套架构，CQRS其实就是读写分离，相信了解过数据库的同学不会对这个概念陌生，在分布式数据库中，通常借助读写分离来保证性能，这也是CQRS最常见的应用场景之一；ES则是不保存对象的最新状态，而是保存对象产生的所有事件，通过事件溯源（Event Sourcing，ES）得到对象最新状态。在Redux中，C端采用Event Sourcing的技术，在EventStore中存储事件；Q端存储对象的最新状态，用于提供查询支持。</p><p>ES近年来在并发编程领域应用的也非常多，例如Scala异步编程库Akka，基于Actor异步编程模型结合了ES。这种架构可以避免状态的竞争和锁，以少量的实时性损耗换取了可靠性，不会出现同时更新一个数据的问题。但是现在前端的复杂度还没有达到分布式场景下后端及数据库的程度，所以现在可能还不能去感受到这套架构带来的好处。</p><p>但是Redux借助CQRS+ES，带来的一个直观的好处就是调试工具的使用，相信使用过的同学一定对时光旅行这个功能印象深刻，可以随意的调节得到每个时刻的应用状态。其实现依赖于在Redux中<code>Action</code>就是<code>Event</code>，<code>Reducer</code>就是状态转换，根据初始<code>State</code>和<code>Event</code>记录，可以推算出每一个时刻的状态。</p><p>说了这么多，Redux带来的坏处是什么呢？主要有两点：<br>第一点，在实际的开发中，我们的操作并非都是同步的，几乎是到处充斥着异步操作，而Redux为了保证自身的纯度，把不可靠的异步问题再一次抛给了用户；第二点，JS的数据结构并非天生的不可变，<code>reducer</code>函数为了追求不可变，大量使用<code>Object.assign()</code>来创建新的状态对象（例如下面这段代码，来自Redux文档），所以会产生很多的中间状态变量，带来性能问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_VISIBILITY_FILTER:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        visibilityFilter: action.filter</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">case</span> ADD_TODO:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        todos: [</span><br><span class="line">          ...state.todos,</span><br><span class="line">          &#123;</span><br><span class="line">            text: action.text,</span><br><span class="line">            completed: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面两点，第一点社区的解决方案是redux-thunk、redux-saga、redux-observable，第二点则是Immutable.js。</p></li><li><p>redux-thunk，redux-saga，redux-observable<br>这一块其实我不是很熟悉，也没有真正在业务中尝试使用过这些方案，就不献丑了，推荐阅读参考资料里的《Redux Thunk vs Saga vs Observable》，当然也期待有同学能够积极分享自己的经验。</p></li><li><p>Immutable.js<br>Immutable.js事实上是和React一起出来的，只是React的光芒掩盖了Immutable.js，直到Redux引入了性能问题，大家才想到了Immutable.js。其实关于Immutable.js也没啥好介绍的，API看官网即可，其实现则可以参考阅读Clojure的数据结构实现。</p></li></ul><h3 id="Reactive-Programming-响应式编程"><a href="#Reactive-Programming-响应式编程" class="headerlink" title="Reactive Programming 响应式编程"></a>Reactive Programming 响应式编程</h3><p>讲FP牵扯到RP很大的原因是因为大多数场景下RP和FP息息相关着。<br>这一块我还欠缺很多，所以暂时不讲太多。</p><ul><li><p>FRP vs F&amp;RP<br>两者区别在于：FRP是基于时间连续的，RP是基于时间离散的。</p></li><li><p>Rx.js<br>Rx不是FRP，而是F&amp;RP，因为Rx并不强调时间的作用，只是借助了函数式编程的一些思想让API变得更加优雅。<br>为什么我们会需要Rx.js呢？推荐阅读《单页应用的数据流方案探索》</p></li><li><p>Cycle.js<br>循环依赖问题<br>函数不动点模型</p></li><li><p>Elm<br>受Haskell影响<br>影响了Redux</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li><a href="http://johnhax.net/2017/stc-vs-ptc/#0" target="_blank" rel="noopener">STC vs PTC</a></li><li><a href="https://zhuanlan.zhihu.com/p/26941235" target="_blank" rel="noopener">[译]All About Recursion, PTC, TCO and STC in JavaScript</a></li></ul><h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/26535479" target="_blank" rel="noopener">如何用 JavaScript 实现一个数组惰性求值库</a></li><li><a href="https://zhuanlan.zhihu.com/p/26587745" target="_blank" rel="noopener">js中的Stream实现</a></li></ul><h2 id="CQRS"><a href="#CQRS" class="headerlink" title="CQRS"></a>CQRS</h2><ul><li><a href="https://martinfowler.com/bliki/CQRS.html" target="_blank" rel="noopener">CQRS</a></li><li><a href="https://github.com/reactjs/redux/issues/351" target="_blank" rel="noopener">Redux and it’s relation to CQRS (and other things)</a></li><li><a href="https://www.slideshare.net/ktoso/akka-persistence-event-sourcing-in-30-minutes" target="_blank" rel="noopener">Akka persistence == event sourcing in 30 minutes</a></li></ul><h2 id="Redux异步解决方案"><a href="#Redux异步解决方案" class="headerlink" title="Redux异步解决方案"></a>Redux异步解决方案</h2><ul><li><a href="http://slides.com/dabit3/deck-11-12#/" target="_blank" rel="noopener">Redux Thunk vs Saga vs Observable</a></li></ul><h2 id="不可变数据"><a href="#不可变数据" class="headerlink" title="不可变数据"></a>不可变数据</h2><ul><li><a href="https://www.zhihu.com/question/53804334" target="_blank" rel="noopener">函数式编程所倡导使用的「不可变数据结构」如何保证性能？</a></li><li><a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1" target="_blank" rel="noopener">Understanding Clojure’s Persistent Vectors, pt. 1</a></li><li><a href="http://hypirion.com/musings/understanding-persistent-vector-pt-2" target="_blank" rel="noopener">Understanding Clojure’s Persistent Vectors, pt. 2</a></li><li><a href="http://hypirion.com/musings/understanding-persistent-vector-pt-3" target="_blank" rel="noopener">Understanding Clojure’s Persistent Vectors, pt. 3</a></li></ul><h2 id="Rx"><a href="#Rx" class="headerlink" title="Rx"></a>Rx</h2><ul><li><a href="https://github.com/ReactiveX/reactivex.github.io/issues/130" target="_blank" rel="noopener">Clarify the differences between Functional Reactive Programming and Reactive Extensions</a></li><li><a href="https://zhuanlan.zhihu.com/p/23331432" target="_blank" rel="noopener">Hello RxJS</a></li></ul><h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><ul><li><a href="https://www.zhihu.com/question/59871249/answer/170400954" target="_blank" rel="noopener">前端开发js函数式编程真实用途体现在哪里？</a></li><li><a href="https://zhuanlan.zhihu.com/p/24076438" target="_blank" rel="noopener">为什么说 JavaScript 不擅长函数式编程</a></li><li><a href="https://zhuanlan.zhihu.com/p/26426054" target="_blank" rel="noopener">单页应用的数据流方案探索</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：这个其实是我最近打算在在团队做的一个分享，这个分享将会聊聊函数式编程在前端的一些成熟的应用以及尝试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FP" scheme="https://blog.daraw.cn/categories/FP/"/>
    
    
      <category term="FP" scheme="https://blog.daraw.cn/tags/FP/"/>
    
      <category term="React" scheme="https://blog.daraw.cn/tags/React/"/>
    
      <category term="Redux" scheme="https://blog.daraw.cn/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>多说一句再见</title>
    <link href="https://blog.daraw.cn/2017/03/23/goodbye-duoshuo/"/>
    <id>https://blog.daraw.cn/2017/03/23/goodbye-duoshuo/</id>
    <published>2017-03-23T20:01:15.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因公司业务调整，非常遗憾的向大家宣布多说项目即将关闭。 我们将于2017年6月1日正式关停服务，在此之前您可以通过后台的数据导出功能导出自己站点的评论数据。 对此给您造成的不便，我们深表歉意，感谢您的一路相伴。</p></blockquote><p>从博客搭建好以来一直使用着多说作为评论系统，虽然多说有着不少的黑点，比如上了HTTPS后失去地址栏绿锁，也听说过多说有各种各样的bug，服务器故障导致评论框不出现更是没少见过，不过以后再也不能黑多说了。  </p><a id="more"></a><p>由于不是很想再去使用国内其他的评论系统了，博客近期也没有迁移到非静态的博客系统的计划，所以把评论系统换成了Disqus。至于GFW的问题，我觉得科学上网是一个程序员必备的技能，Disqus被墙不应该会影响本博客的访客们。  </p><p>另外可能是多说导出数据的格式的问题，在迁移到Disqus的过程中一直没法把转好的数据导入Disqus，所以很遗憾以前的评论都丢失了，最近也比较忙，过阵子闲下来我再尝试看看能不能把数据找回来。  </p><p>感谢多说这一年半的陪伴，也感谢曾经在博客留言的朋友们。<br>如果可以，我还是很乐意为多说团队买一杯咖啡的。  </p><p>最后，再多说一句再见！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;因公司业务调整，非常遗憾的向大家宣布多说项目即将关闭。 我们将于2017年6月1日正式关停服务，在此之前您可以通过后台的数据导出功能导出自己站点的评论数据。 对此给您造成的不便，我们深表歉意，感谢您的一路相伴。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从博客搭建好以来一直使用着多说作为评论系统，虽然多说有着不少的黑点，比如上了HTTPS后失去地址栏绿锁，也听说过多说有各种各样的bug，服务器故障导致评论框不出现更是没少见过，不过以后再也不能黑多说了。  &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="多说" scheme="https://blog.daraw.cn/tags/%E5%A4%9A%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>《你不知道的JS上卷》阅读小记之setTimeout的this指向问题</title>
    <link href="https://blog.daraw.cn/2017/02/19/notes-about-you-dont-know-js-settimeout-this/"/>
    <id>https://blog.daraw.cn/2017/02/19/notes-about-you-dont-know-js-settimeout-this/</id>
    <published>2017-02-19T10:10:05.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<p>这几天翻看了下被传的神乎其神的《你不知道的JS》这本书，其实以前就看过一次，不过当时的level并不高，而且感觉这本书讲的有点绕，所以看了一点就没坚持下去。<br>这次翻看感觉还是比较轻松的，有些地方写的很好，有的地方还是感觉讲的有点绕（可能是翻译的问题），但总的来说这本书还是很不错的，基本都是JS中有坑、新手难以理解的点，简直就是《JS：The Bad Parts》（哈，开个玩笑~）。<br>这个小记不是打算记录书中内容的笔记，而是想补充纠正书中的讲的不完善的地方。</p><a id="more"></a><h2 id="this的问题"><a href="#this的问题" class="headerlink" title="this的问题"></a>this的问题</h2><p>在第二部分<code>2.2.2隐式绑定</code>一节中，提到了<code>setTimeout</code>的传入函数this的问题，书里说传入回调函数在执行的时候<code>context</code>为全局对象，所以<code>this</code>指向了全局对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><p>在Chrome56中测试上面的一段代码确实输出为<code>window</code>全局对象，符合书中的描述，然而如果你在Node.js中测试这段代码你会发现输出是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  Desktop  node -v</span><br><span class="line">v6.8.1</span><br><span class="line">➜  Desktop  node test.js</span><br><span class="line">Timeout &#123;</span><br><span class="line">  _called: true,</span><br><span class="line">  _idleTimeout: 200,</span><br><span class="line">  _idlePrev: null,</span><br><span class="line">  _idleNext: null,</span><br><span class="line">  _idleStart: 94,</span><br><span class="line">  _onTimeout: [Function],</span><br><span class="line">  _timerArgs: undefined,</span><br><span class="line">  _repeat: null &#125;</span><br></pre></td></tr></table></figure><p>What? 输出的是一个Timeout实例对象！<br>打开node的源码，在<code>node\timers.js</code>中有着<code>setTimeout</code>的实现，这里大概的讲一下，有兴趣的可以自己再去看看代码：<br>有一个<code>Timeout</code>构造函数，用来构造定时器对象，用一个链表存着所有的<code>Timeout</code>的实例对象，也就是每次执行暴露出来的<code>setTimeout</code>都会在链表中插入一个<code>Timeout</code>实例<code>timer</code>。下面是<code>Timeout</code>构造函数的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timeout</span>(<span class="params">after, callback, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._called = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>._idleTimeout = after;</span><br><span class="line">  <span class="keyword">this</span>._idlePrev = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>._idleNext = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>._idleStart = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>._onTimeout = callback;</span><br><span class="line">  <span class="keyword">this</span>._timerArgs = args;</span><br><span class="line">  <span class="keyword">this</span>._repeat = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时的部分<code>TimerWrap</code>则由C++来做处理，这里不是现在我们关注的关键点也脱离了JS的范畴暂且不细谈，在定时结束后，通过<code>ontimeout</code>函数来处理<code>timer</code>对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ontimeout</span>(<span class="params">timer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = timer._timerArgs;</span><br><span class="line">  <span class="keyword">var</span> callback = timer._onTimeout;</span><br><span class="line">  <span class="keyword">if</span> (!args)</span><br><span class="line">    callback.call(timer);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (args.length) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        callback.call(timer, args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        callback.call(timer, args[<span class="number">0</span>], args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        callback.call(timer, args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        callback.apply(timer, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (timer._repeat)</span><br><span class="line">    rearm(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ontimeout</code>函数中正藏着<code>this</code>指向问题的真相：<code>callback.call(timer, ...)</code>。  </p><p>在JS中，<code>setTimeout</code>应该是属于<code>Event Loop</code>的<code>Macro Tasks</code>，与<code>I/O</code>等<code>Tasks</code>同等级，在浏览器中有<code>Web APIs</code>规范来定义这部分的实现，node没有（或者是我没找到，还请告知）。但我大概翻了下<code>Web APIs</code>的规范，也没有找到对<code>this</code> <code>context</code> 的规定。虽然不理解为什么node这样做，但是好歹也找出了与Chrome浏览器不同的原因。  </p><p>所以，关于<code>setTimeout</code>传入函数的<code>this</code>，我的建议是即使你写的代码只会在浏览器里运行，也最好不要依赖<code>this</code>会自动绑定到全局对象上去，而是应该手动借助<code>bind</code>绑定。当然使用ES6的箭头函数是没什么问题的，因为没有创建新的<code>context</code>，<code>this</code>都会毫无疑问的绑定在当前的<code>context</code>上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> == that) <span class="comment">// true</span></span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天翻看了下被传的神乎其神的《你不知道的JS》这本书，其实以前就看过一次，不过当时的level并不高，而且感觉这本书讲的有点绕，所以看了一点就没坚持下去。&lt;br&gt;这次翻看感觉还是比较轻松的，有些地方写的很好，有的地方还是感觉讲的有点绕（可能是翻译的问题），但总的来说这本书还是很不错的，基本都是JS中有坑、新手难以理解的点，简直就是《JS：The Bad Parts》（哈，开个玩笑~）。&lt;br&gt;这个小记不是打算记录书中内容的笔记，而是想补充纠正书中的讲的不完善的地方。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://blog.daraw.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://blog.daraw.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6实现内部类的写法</title>
    <link href="https://blog.daraw.cn/2017/01/17/es6-static-class/"/>
    <id>https://blog.daraw.cn/2017/01/17/es6-static-class/</id>
    <published>2017-01-17T16:55:15.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<p>最近在把 <code>JIris</code> 移植到JS平台 <code>Iris.js</code> 的过程中不断的在Java和JS两种语言之间切换，ES6的 <code>Class</code> 某种程度来说可以写出更加优雅的代码，而不用去管背后的原型实现。但是不得不说有一个遗憾就是 ES6 虽然支持了静态方法，但是还不支持静态属性和静态类，于是仔细观察了下发现了几种ES6实现静态类的相对优雅的写法。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>简化一个Demo，先是 Java 的写法：<br>** IrisValue.java **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IrisValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IrisValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mValue = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        mValue = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> test = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> test;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTest</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            test = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IrisValue irisValue = <span class="keyword">new</span> IrisValue(<span class="number">10</span>);</span><br><span class="line">        IrisValue irisValue2 = <span class="keyword">new</span> IrisValue(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        irisValue.setValue(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(irisValue.getValue());</span><br><span class="line">        System.out.println(irisValue2.getValue());</span><br><span class="line"></span><br><span class="line">        Test testValue = <span class="keyword">new</span> Test();</span><br><span class="line">        Test testValue2 = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">        System.out.println(testValue.getTest());</span><br><span class="line">        System.out.println(testValue2.getTest());</span><br><span class="line">        testValue.setTest(<span class="number">9</span>);</span><br><span class="line">        testValue2.setTest(<span class="number">99</span>);</span><br><span class="line">        System.out.println(testValue.getTest());</span><br><span class="line">        System.out.println(testValue2.getTest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Test</code> 是<code>IrisValue</code>类的静态方法，并不属于<code>IrisValue</code>的实例对象。上面代码执行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">10</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">9</span><br><span class="line">99</span><br></pre></td></tr></table></figure><p>那么等同的JS代码应该怎么写呢？<br>ES6的Class本质还是函数，所以有一个很容易想到的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IrisValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mValue = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> value() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> value(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mValue = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.mTest = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> test() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mTest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> test(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mTest = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IrisValue.Test = Test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> irisValue = <span class="keyword">new</span> IrisValue(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> irisValue2 = <span class="keyword">new</span> IrisValue(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">irisValue.value = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(irisValue.value);</span><br><span class="line"><span class="built_in">console</span>.log(irisValue2.value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testValue = <span class="keyword">new</span> IrisValue.Test();</span><br><span class="line"><span class="keyword">let</span> testValue2 = <span class="keyword">new</span> IrisValue.Test();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(testValue.test);</span><br><span class="line"><span class="built_in">console</span>.log(testValue2.test);</span><br><span class="line">testValue.test = <span class="number">9</span>;</span><br><span class="line">testValue2.test = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(testValue.test);</span><br><span class="line"><span class="built_in">console</span>.log(testValue2.test);</span><br></pre></td></tr></table></figure><p>输出结果和上面Java（预想的）一样，静态属性目前也能这样实现。  </p><p>但是不要忘了<code>get/set</code>函数，所以应该有更加优雅的静态类和静态属性的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IrisValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mValue = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> value() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> value(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mValue = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> Test() &#123;</span><br><span class="line">    <span class="keyword">return</span> Test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.mTest = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> test() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mTest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> test(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mTest = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我们还能再<del>优雅</del>一点～</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IrisValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mValue = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> value() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> value(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mValue = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> Test() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">            <span class="keyword">constructor</span>() &#123;</span><br><span class="line">                <span class="keyword">this</span>.mTest = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">get</span> test() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.mTest;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">set</span> test(value) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mTest = value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面的这些写法还是不够优雅，避免不了的牺牲了可读性。既然ES6已经引进了Class，期待以后能和Java一样去写静态类和静态属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在把 &lt;code&gt;JIris&lt;/code&gt; 移植到JS平台 &lt;code&gt;Iris.js&lt;/code&gt; 的过程中不断的在Java和JS两种语言之间切换，ES6的 &lt;code&gt;Class&lt;/code&gt; 某种程度来说可以写出更加优雅的代码，而不用去管背后的原型实现。但是不得不说有一个遗憾就是 ES6 虽然支持了静态方法，但是还不支持静态属性和静态类，于是仔细观察了下发现了几种ES6实现静态类的相对优雅的写法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.daraw.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="https://blog.daraw.cn/categories/%E5%89%8D%E7%AB%AF/ES6/"/>
    
    
      <category term="ES6" scheme="https://blog.daraw.cn/tags/ES6/"/>
    
      <category term="Class" scheme="https://blog.daraw.cn/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA在Linux下字体不正常解决方案</title>
    <link href="https://blog.daraw.cn/2016/11/24/intellij-idea-ugly-font-linux/"/>
    <id>https://blog.daraw.cn/2016/11/24/intellij-idea-ugly-font-linux/</id>
    <published>2016-11-24T20:34:15.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<p>之前遇到了一件奇怪的事，WebStorm中字体正常，IDEA直接导入WebStorm的设置备份也还是不行，如图所示。</p><a id="more"></a><p><img src="https://ww1.sinaimg.cn/large/005KE4htgw1f9hf9q1cy0j31hc0u0181.jpg" alt></p><p>本来这事也就放着不管了，昨天和Shaoxing聊天提到了这事，他提醒我正常情况下IDEA系列应该都是自带JDK的，于是我查了一下IDEA有带和不带JDK两个版本，自带JDK的会针对HiDPI和字体做一些优化。  </p><p>我打开了WS和IDEA进行对比，发现他们的About信息中的JVM版本果然不一样：<br><img src="https://ww1.sinaimg.cn/large/005KE4htgw1fa3hgndesmj30hy0b6q6l.jpg" alt><br><img src="https://ww1.sinaimg.cn/mw690/005KE4htgw1fa3hgo3t08j30ia0bkae3.jpg" alt>  </p><p>在IDEA的设置里手动切换了JVM版本后IDEA会自动重启，然而并没什么卵用，重启后JVM又回到了Oracle版本。<br>我突然想起曾经在环境变量中配置过<code>IDEA_JDK</code>，于是删除了这个变量，在终端中输出这个变量已经不存在，然而还是不行。  </p><p>这时看到官网说可以在<code>idea.sh</code>中手动添加<code>IDEA_JDK</code>变量，于是我打开了<code>idea.sh</code>，其中60行往后为关键点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Locate a JDK installation directory which will be used to run the IDE.</span></span><br><span class="line"><span class="comment"># Try (in order): IDEA_JDK, idea.jdk, ../jre, JDK_HOME, JAVA_HOME, "java" in PATH.</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$IDEA_JDK</span>"</span> -a -x <span class="string">"<span class="variable">$IDEA_JDK</span>/bin/java"</span> ]; <span class="keyword">then</span></span><br><span class="line">  JDK=<span class="string">"<span class="variable">$IDEA_JDK</span>"</span></span><br><span class="line"><span class="keyword">elif</span> [ -s <span class="string">"<span class="variable">$HOME</span>/.IntelliJIdea2016.3/config/idea.jdk"</span> ]; <span class="keyword">then</span></span><br><span class="line">  JDK=`<span class="string">"<span class="variable">$CAT</span>"</span> <span class="variable">$HOME</span>/.IntelliJIdea2016.3/config/idea.jdk`</span><br><span class="line">  <span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$JDK</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    JDK=<span class="string">"<span class="variable">$IDE_HOME</span>/<span class="variable">$JDK</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">elif</span> [ -x <span class="string">"<span class="variable">$IDE_HOME</span>/jre/jre/bin/java"</span> ] &amp;&amp; <span class="string">"<span class="variable">$IDE_HOME</span>/jre/jre/bin/java"</span> -version &gt; /dev/null 2&gt;&amp;1 ; <span class="keyword">then</span></span><br><span class="line">  JDK=<span class="string">"<span class="variable">$IDE_HOME</span>/jre"</span></span><br><span class="line"><span class="keyword">elif</span> [ -n <span class="string">"<span class="variable">$JDK_HOME</span>"</span> -a -x <span class="string">"<span class="variable">$JDK_HOME</span>/bin/java"</span> ]; <span class="keyword">then</span></span><br><span class="line">  JDK=<span class="string">"<span class="variable">$JDK_HOME</span>"</span></span><br><span class="line"><span class="keyword">elif</span> [ -n <span class="string">"<span class="variable">$JAVA_HOME</span>"</span> -a -x <span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span> ]; <span class="keyword">then</span></span><br><span class="line">  JDK=<span class="string">"<span class="variable">$JAVA_HOME</span>"</span></span><br></pre></td></tr></table></figure><p>后面的代码省去，虽然没学过<code>shell</code>，但很明显查找JDK的流程为先查看环境变量有没有<code>IDEA_JDK</code>变量，如果没有再去看配置信息里有没有设置<code>idea.jdk</code>，如果没有再去找IDE的目录里自带的JDK。<br>所以解决方法很简单了，把上面的流程注释掉，直接去IDE的目录下找自带的JDK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Locate a JDK installation directory which will be used to run the IDE.</span></span><br><span class="line"><span class="comment"># Try (in order): IDEA_JDK, idea.jdk, ../jre, JDK_HOME, JAVA_HOME, "java" in PATH.</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># if [ -n "$IDEA_JDK" -a -x "$IDEA_JDK/bin/java" ]; then</span></span><br><span class="line"><span class="comment">#   JDK="$IDEA_JDK"</span></span><br><span class="line"><span class="comment"># elif [ -s "$HOME/.IntelliJIdea2016.3/config/idea.jdk" ]; then</span></span><br><span class="line"><span class="comment">#   JDK=`"$CAT" $HOME/.IntelliJIdea2016.3/config/idea.jdk`</span></span><br><span class="line"><span class="comment">#   if [ ! -d "$JDK" ]; then</span></span><br><span class="line"><span class="comment">#     JDK="$IDE_HOME/$JDK"</span></span><br><span class="line"><span class="comment">#   fi</span></span><br><span class="line"><span class="comment"># elif [ -x "$IDE_HOME/jre/jre/bin/java" ] &amp;&amp; "$IDE_HOME/jre/jre/bin/java" -version &gt; /dev/null 2&gt;&amp;1 ; then</span></span><br><span class="line"><span class="keyword">if</span> [ -x <span class="string">"<span class="variable">$IDE_HOME</span>/jre/jre/bin/java"</span> ] &amp;&amp; <span class="string">"<span class="variable">$IDE_HOME</span>/jre/jre/bin/java"</span> -version &gt; /dev/null 2&gt;&amp;1 ; <span class="keyword">then</span></span><br><span class="line">  JDK=<span class="string">"<span class="variable">$IDE_HOME</span>/jre"</span></span><br><span class="line"><span class="keyword">elif</span> [ -n <span class="string">"<span class="variable">$JDK_HOME</span>"</span> -a -x <span class="string">"<span class="variable">$JDK_HOME</span>/bin/java"</span> ]; <span class="keyword">then</span></span><br><span class="line">  JDK=<span class="string">"<span class="variable">$JDK_HOME</span>"</span></span><br><span class="line"><span class="keyword">elif</span> [ -n <span class="string">"<span class="variable">$JAVA_HOME</span>"</span> -a -x <span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span> ]; <span class="keyword">then</span></span><br><span class="line">  JDK=<span class="string">"<span class="variable">$JAVA_HOME</span>"</span></span><br></pre></td></tr></table></figure><p>保存后打开IDEA，果然一切都正常了，About信息中也显示使用了自带的JDK。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前遇到了一件奇怪的事，WebStorm中字体正常，IDEA直接导入WebStorm的设置备份也还是不行，如图所示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.daraw.cn/categories/Linux/"/>
    
    
      <category term="Intellij IDEA" scheme="https://blog.daraw.cn/tags/Intellij-IDEA/"/>
    
      <category term="Linux" scheme="https://blog.daraw.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>node-thunkify源码阅读笔记</title>
    <link href="https://blog.daraw.cn/2016/11/11/notes-about-node-thunkify/"/>
    <id>https://blog.daraw.cn/2016/11/11/notes-about-node-thunkify/</id>
    <published>2016-11-11T16:00:15.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<p>Node7发布后已经可以通过添加<code>--harmony-async-await</code>的参数调用来直接支持<code>async/await</code>语法了，据说Node8还会进一步推进其发展，于是研究了一下JS的异步流程控制和下一代Node Web框架<code>Koa2</code>。  </p><p>关于<code>generator</code> <code>async/await</code>的发展史已有一大堆文章讲过了，这里不再赘述。<br>tj的<code>co</code>是<code>Koa2</code>上个大版本<code>Koa1</code>的核心，在没有<code>async/await</code>的时候一般会借助<code>co</code>来做自动流程控制。关于<code>co</code>的源码分析文章也有很多，代码不长值得一读，参考了一些分析文章也算是了解了其逻辑和思路。</p><p>在<code>co</code>中出现了一个<code>thunkToPromise</code>的函数，一些文章都跳过了这个并表示<code>thunk</code>函数已经没什么意义了，但本着好奇心读了阮一峰的<a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html" target="_blank" rel="noopener">Thunk 函数的含义和用法</a>，文中一个地方一时没有搞懂，故写此文记录一下。</p><a id="more"></a><p><code>thunkify</code>的<a href="https://github.com/tj/node-thunkify/blob/master/index.js" target="_blank" rel="noopener">代码</a>很少，就是一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  assert(<span class="string">'function'</span> == <span class="keyword">typeof</span> fn, <span class="string">'function required'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">      args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> called;</span><br><span class="line"></span><br><span class="line">      args.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        done.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn.apply(ctx, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        done(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b, callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = a + b;</span><br><span class="line">  callback(sum);</span><br><span class="line">  callback(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ft = thunkify(f);</span><br><span class="line">ft(<span class="number">1</span>, <span class="number">2</span>)(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>让我一时没有搞懂的是为什么借助<code>called</code>标记能够确保回调函数只执行一次，借助VS Code的断点调试把文中示例的代码跑了一遍总算搞懂了：  </p><p>Demo中首先真正执行的是<code>thunkify(f)</code>，<code>f</code>函数传入<code>thunkify</code>后直接返回了一个闭包，这里称之为闭包1，闭包1被赋值给了ft，ft即为闭包1的一个引用。<br>接着执行的是<code>ft(1, 2)</code>，<code>ft</code>中传入了<code>(1, 2)</code>来执行，<code>ft</code>中将<code>duck type</code>的伪数组<code>arguments</code>保存为一个真实数组<code>args</code>，所以此时<code>args</code>数组中有两个成员即<code>1</code>和<code>2</code>，<code>ft</code>最后又返回了一个闭包，这里称之为闭包2。<br>接着执行的是<code>ft(1, 2)(console.log)</code>，也就是将<code>console.log</code>传入闭包2来执行，传入的<code>console.log</code>即形参<code>done</code>其实就是一开始<code>f</code>的回调函数，这时候重点来了，在闭包2中增加了一个标记<code>called</code>来记录回调是否执行过一次了，而<code>push</code>进<code>args</code>数组的函数则已经不是单纯的回调，而是被包裹了原回调、保证只会执行一次的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">  called = <span class="literal">true</span>;</span><br><span class="line">  done.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后执行的就是<code>fn.apply(ctx, args)</code>，而<code>thunkify</code>函数的形参<code>fn</code>对应的就是一开始传入的<code>f</code>函数，所以总的看来，真正执行的还是最初的<code>f</code>函数，而被改变的是传入的回调，回调被包裹了一层，借助<code>called</code>标记来保证只会被执行一次，执行过后<code>called</code>标记被改变，不再会被执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node7发布后已经可以通过添加&lt;code&gt;--harmony-async-await&lt;/code&gt;的参数调用来直接支持&lt;code&gt;async/await&lt;/code&gt;语法了，据说Node8还会进一步推进其发展，于是研究了一下JS的异步流程控制和下一代Node Web框架&lt;code&gt;Koa2&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;generator&lt;/code&gt; &lt;code&gt;async/await&lt;/code&gt;的发展史已有一大堆文章讲过了，这里不再赘述。&lt;br&gt;tj的&lt;code&gt;co&lt;/code&gt;是&lt;code&gt;Koa2&lt;/code&gt;上个大版本&lt;code&gt;Koa1&lt;/code&gt;的核心，在没有&lt;code&gt;async/await&lt;/code&gt;的时候一般会借助&lt;code&gt;co&lt;/code&gt;来做自动流程控制。关于&lt;code&gt;co&lt;/code&gt;的源码分析文章也有很多，代码不长值得一读，参考了一些分析文章也算是了解了其逻辑和思路。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;co&lt;/code&gt;中出现了一个&lt;code&gt;thunkToPromise&lt;/code&gt;的函数，一些文章都跳过了这个并表示&lt;code&gt;thunk&lt;/code&gt;函数已经没什么意义了，但本着好奇心读了阮一峰的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/05/thunk.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Thunk 函数的含义和用法&lt;/a&gt;，文中一个地方一时没有搞懂，故写此文记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://blog.daraw.cn/categories/JavaScript/"/>
    
    
      <category term="thunkify" scheme="https://blog.daraw.cn/tags/thunkify/"/>
    
  </entry>
  
  <entry>
    <title>如何监听JS变量的变化</title>
    <link href="https://blog.daraw.cn/2016/08/17/how-to-monitor-changes-of-js-variable/"/>
    <id>https://blog.daraw.cn/2016/08/17/how-to-monitor-changes-of-js-variable/</id>
    <published>2016-08-17T13:48:39.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.zhihu.com/question/44724640" target="_blank" rel="noopener">如何监听 js 中变量的变化?</a><br>我现在有这样一个需求，需要监控js的某个变量的改变，如果该变量发生变化，则触发一些事件，不能使用timeinterval之类的定时去监控的方法，不知道有比较好的解决方案么？</p></blockquote><p>这个问题问的很好。  </p><p>流行的MVVM的JS库/框架都有共同的特点就是数据绑定，在数据变更后响应式的自动进行相关计算并变更DOM展现。所以这个问题也可以理解为<strong>如何实现MVVM库/框架的数据绑定</strong>。  </p><p>常见的数据绑定的实现有脏值检测，基于ES5的<code>getter</code>和<code>setter</code>，以及ES已被废弃的<code>Object.observe</code>，和ES6中添加的<code>Proxy</code>。</p><a id="more"></a><h2 id="脏值检测"><a href="#脏值检测" class="headerlink" title="脏值检测"></a>脏值检测</h2><p>angular使用的就是脏值检测，原理是比较新值和旧值，当值真的发生改变时再去更改DOM，所以angular中有一个<code>$digest</code>。那么为什么在像<code>ng-click</code>这样的内置指令在触发后会自动变更呢？原理也很简单，在<code>ng-click</code>这样的内置指令中最后追加了<code>$digest</code>。  </p><p>简易的实现一个脏值检测：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>two-way binding<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">ng-click</span>=<span class="string">"inc"</span>&gt;</span></span><br><span class="line">            Increase</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">ng-click</span>=<span class="string">"reset"</span>&gt;</span></span><br><span class="line">            Reset</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color:red"</span> <span class="attr">ng-bind</span>=<span class="string">"counter"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color:blue"</span> <span class="attr">ng-bind</span>=<span class="string">"counter"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color:green"</span> <span class="attr">ng-bind</span>=<span class="string">"counter"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">/* 数据模型区开始 */</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> counter = <span class="number">0</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">                counter = 0;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">/* 数据模型区结束 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="comment">/* 绑定关系区开始 */</span></span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">                bind();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">bind</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> list = <span class="built_in">document</span>.querySelectorAll(<span class="string">"[ng-click]"</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;list.length; i++) &#123;</span></span><br><span class="line"><span class="actionscript">                    list[i].onclick = (<span class="function"><span class="keyword">function</span><span class="params">(index)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                            <span class="built_in">window</span>[list[index].getAttribute(<span class="string">"ng-click"</span>)]();</span></span><br><span class="line">                            apply();</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;)(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> list = <span class="built_in">document</span>.querySelectorAll(<span class="string">"[ng-bind='counter']"</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;list.length; i++) &#123;</span></span><br><span class="line">                    if (list[i].innerHTML != counter) &#123;</span><br><span class="line">                        list[i].innerHTML = counter;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">/* 绑定关系区结束 */</span></span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样做的坏处是自己变更数据后，是无法自动改变DOM的，必须要想办法触发<code>apply()</code>，所以只能借助<code>ng-click</code>的包装，在<code>ng-click</code>中包含真实的<code>click</code>事件监听并追加脏值检测以判断是否要更新DOM。  </p><p>另外一个坏处是如果不注意，每次脏值检测会检测大量的数据，而很多数据是没有检测的必要的，容易影响性能。  </p><p>关于如何实现一个和angular一样的脏值检测，知道原理后还有很多工作要去做，以及如何优化等等。如果有兴趣可以看看民工叔曾经推荐的《Build Your Own Angular.js》，第一章<code>Scope</code>便讲了如何实现angular的作用域和脏值检测。对了，上面的例子也是从民工叔的博客稍加修改来的，建议最后去看下原文，链接在参考资料中。</p><h2 id="ES5的getter与setter"><a href="#ES5的getter与setter" class="headerlink" title="ES5的getter与setter"></a>ES5的<code>getter</code>与<code>setter</code></h2><p>在ES5中新增了一个<code>Object.defineProperty</code>，直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure><p>其接受的第三个参数可以取<code>get</code>和<code>set</code>并各自对应一个<code>getter</code>和<code>setter</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">zhihu</span>:<span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'zhihu'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get：'</span> + zhihu);</span><br><span class="line">    <span class="keyword">return</span> zhihu;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(value) &#123;</span><br><span class="line">    zhihu = value;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set:'</span> + zhihu);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a.zhihu = <span class="number">2</span>; <span class="comment">// set:2</span></span><br><span class="line"><span class="built_in">console</span>.log(a.zhihu); <span class="comment">// get：2</span></span><br><span class="line">                      <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>基于ES5的<code>getter</code>和<code>setter</code>可以说几乎完美符合了要求。为什么要说<code>几乎</code>呢？  </p><p>首先IE8及更低版本IE是无法使用的，而且这个特性是没有<code>polyfill</code>的，无法在不支持的平台实现，<br>这也是基于ES5<code>getter</code>和<code>setter</code>的Vue.js不支持IE8及更低版本IE的原因。也许有人会提到<code>avalon</code>，<code>avalon</code>在低版本IE借助<code>vbscript</code>一些黑魔法实现了类似的功能。  </p><p>除此之外，还有一个问题就是修改数组的<code>length</code>，直接用索引设置元素如<code>items[0] = {}</code>，以及数组的<code>push</code>等变异方法是无法触发<code>setter</code>的。<br>如果想要解决这个问题可以参考Vue的做法，在Vue的<code>observer/array.js</code>中，Vue直接修改了数组的原型方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">;[</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line">.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">var</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// avoid leaking arguments:</span></span><br><span class="line">    <span class="comment">// http://jsperf.com/closure-with-arguments</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="built_in">arguments</span>.length</span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(i)</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      args[i] = <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">var</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">var</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样重写了原型方法，在执行数组变异方法后依然能够触发视图的更新。  </p><p>但是这样还是不能解决修改数组的<code>length</code>和直接用索引设置元素如<code>items[0] = {}</code>的问题，想要解决依然可以参考Vue的做法：<br>前一个问题可以直接用新的数组代替旧的数组；后一个问题可以为数组拓展一个<code>$set</code>方法，在执行修改后顺便触发视图的更新。</p><h2 id="已被废弃的Object-observe"><a href="#已被废弃的Object-observe" class="headerlink" title="已被废弃的Object.observe"></a>已被废弃的<code>Object.observe</code></h2><p><code>Object.observe</code>曾在ES7的草案中，并在提议中进展到stage2，最终依然被废弃。<br>这里只举一个MDN上的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个数据模型</span></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  id: <span class="number">0</span>,</span><br><span class="line">  name: <span class="string">'Brendan Eich'</span>,</span><br><span class="line">  title: <span class="string">'Mr.'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用户的greeting</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateGreeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  user.greeting = <span class="string">'Hello, '</span> + user.title + <span class="string">' '</span> + user.name + <span class="string">'!'</span>;</span><br><span class="line">&#125;</span><br><span class="line">updateGreeting();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.observe(user, <span class="function"><span class="keyword">function</span>(<span class="params">changes</span>) </span>&#123;</span><br><span class="line">  changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">change</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当name或title属性改变时, 更新greeting</span></span><br><span class="line">    <span class="keyword">if</span> (change.name === <span class="string">'name'</span> || change.name === <span class="string">'title'</span>) &#123;</span><br><span class="line">      updateGreeting();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于是已经废弃了的特性，Chrome虽然曾经支持但也已经废弃了支持，这里不再讲更多，有兴趣可以搜一搜以前的文章，这曾经是一个被看好的特性（<a href="http://div.io/topic/600" target="_blank" rel="noopener">Object.observe()带来的数据绑定变革</a>）。<br>当然关于它也有一些替代品<a href="https://github.com/polymer/observe-js" target="_blank" rel="noopener">Polymer/observe-js</a>。</p><h2 id="ES6带来的Proxy"><a href="#ES6带来的Proxy" class="headerlink" title="ES6带来的Proxy"></a>ES6带来的<code>Proxy</code></h2><p>人如其名，类似HTTP中的代理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p><code>target</code>为目标对象，可以是任意类型的对象，比如数组，函数，甚至是另外一个代理对象。<br><code>handler</code>为处理器对象，包含了一组代理方法，分别控制所生成代理对象的各种行为。</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(obj, prop, value) &#123;</span><br><span class="line">    obj[prop] = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'zhihu'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"set "</span> + prop + <span class="string">": "</span> + obj[prop]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a.zhihu = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>当然，<code>Proxy</code>的能力远不止此，还可以实现代理转发等等。  </p><p>但是要注意的是目前浏览器中只有Firefox18支持这个特性，而babel官方也表明不支持这个特性：</p><blockquote><p>Unsupported feature<br>Due to the limitations of ES5, Proxies cannot be transpiled or polyfilled.</p></blockquote><p>目前已经有babel插件可以实现，但是据说实现的比较复杂。<br>如果是Node的话升级到目前的最新版本应该就可以使用了，上面的例子测试环境为Node v6.4.0。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://github.com/xufei/blog/issues/10" target="_blank" rel="noopener">Angular沉思录（一）数据绑定</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty() - JavaScript | MDN</a></li><li><a href="https://github.com/vuejs/vue/blob/dev/src/observer/array.js" target="_blank" rel="noopener">vue/array.js at dev · vuejs/vue</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/observe" target="_blank" rel="noopener">Object.observe() - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">Proxy - JavaScript | MDN</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/44724640&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何监听 js 中变量的变化?&lt;/a&gt;&lt;br&gt;我现在有这样一个需求，需要监控js的某个变量的改变，如果该变量发生变化，则触发一些事件，不能使用timeinterval之类的定时去监控的方法，不知道有比较好的解决方案么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题问的很好。  &lt;/p&gt;
&lt;p&gt;流行的MVVM的JS库/框架都有共同的特点就是数据绑定，在数据变更后响应式的自动进行相关计算并变更DOM展现。所以这个问题也可以理解为&lt;strong&gt;如何实现MVVM库/框架的数据绑定&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;常见的数据绑定的实现有脏值检测，基于ES5的&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;，以及ES已被废弃的&lt;code&gt;Object.observe&lt;/code&gt;，和ES6中添加的&lt;code&gt;Proxy&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://blog.daraw.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://blog.daraw.cn/tags/JavaScript/"/>
    
      <category term="Proxy" scheme="https://blog.daraw.cn/tags/Proxy/"/>
    
      <category term="脏值检测" scheme="https://blog.daraw.cn/tags/%E8%84%8F%E5%80%BC%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>JS实现自定义事件</title>
    <link href="https://blog.daraw.cn/2016/08/02/javascript-event-emitter/"/>
    <id>https://blog.daraw.cn/2016/08/02/javascript-event-emitter/</id>
    <published>2016-08-02T22:30:00.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><blockquote><p>请实现下面的自定义事件Event对象的接口，功能见注释（测试1）<br>该Event对象的接口需要能被其他对象拓展复用（测试2）</p></blockquote><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 1</span></span><br><span class="line">Event.on(<span class="string">"test"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">Event.on(<span class="string">"test"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"test"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">Event.emit(<span class="string">"test"</span>, <span class="string">"hello world"</span>); <span class="comment">// 输出“hello world”和”test”</span></span><br><span class="line"><span class="comment">//测试2</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(person1, Event);</span><br><span class="line"><span class="built_in">Object</span>.assign(person2, Event);</span><br><span class="line"></span><br><span class="line">person1.on(<span class="string">"call1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"person1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">person2.on(<span class="string">"call2"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"person2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person1.emit(<span class="string">"call1"</span>); <span class="comment">// 输出“person1”</span></span><br><span class="line">person1.emit(<span class="string">"call2"</span>); <span class="comment">// 没有输出</span></span><br><span class="line">person2.emit(<span class="string">"call1"</span>); <span class="comment">// 没有输出</span></span><br><span class="line">person2.emit(<span class="string">"call2"</span>); <span class="comment">// 输出”person2”</span></span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是个经典的自定义事件，实现”Pub/Sub”，Node.js中有个比较完善的实现<code>EventEmitter</code>。  </p><p>原理则是构造出一个集成队列的对象，每一个事件对应对象的一个队列，在自定义事件后将回调函数入队，触发事件后回调函数依次出队并执行。  </p><p>个人偏爱IIFE+构造器模式+原型模式，于是有了下面的一个简易实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  EventEmitter.prototype.on = <span class="function"><span class="keyword">function</span> (<span class="params">type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._cbQueue = <span class="keyword">this</span>._cbQueue || &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>._cbQueue[type] = <span class="keyword">this</span>._cbQueue[type]|| [];</span><br><span class="line">    <span class="keyword">this</span>._cbQueue[type].push(handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> (<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._cbQueue[type]) &#123;</span><br><span class="line">      <span class="keyword">this</span>._cbQueue[type].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">        cb(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  exports.EventEmitter = EventEmitter;</span><br><span class="line"></span><br><span class="line">&#125;(global));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Event = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test 1</span></span><br><span class="line">Event.on(<span class="string">"test"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">Event.on(<span class="string">"test"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"test"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">Event.emit(<span class="string">"test"</span>, <span class="string">"hello world"</span>); <span class="comment">// 输出“hello world”和”test”</span></span><br></pre></td></tr></table></figure><p>这样便满足了测试1的要求，然而这样对于测试2是不行的，因为<code>Object.assign()</code>方法不能复制不可遍历的属性和继承属性，也就意味着<code>Event</code>对象上的<code>on</code>和<code>emit</code>不能被复制过去。那么复制<code>Event.prototype</code>对象呢？这样确实是可行的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test2</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(person1, EventEmitter.prototype);</span><br><span class="line"><span class="built_in">Object</span>.assign(person2, EventEmitter.prototype);</span><br><span class="line"></span><br><span class="line">person1.on(<span class="string">"call1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"person1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">person2.on(<span class="string">"call2"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"person2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person1.emit(<span class="string">"call1"</span>); <span class="comment">// 输出“person1”</span></span><br><span class="line">person1.emit(<span class="string">"call2"</span>); <span class="comment">// 没有输出</span></span><br><span class="line">person2.emit(<span class="string">"call1"</span>); <span class="comment">// 没有输出</span></span><br><span class="line">person2.emit(<span class="string">"call2"</span>); <span class="comment">// 输出”person2”</span></span><br></pre></td></tr></table></figure><p>虽然差不多实现了题目中的要求，但是和题目中的要求依然有些偏差，于是我又想到了，如果放弃原型模式+构造器模式，单纯的把Event作为一个对象而不是一个函数呢？<br>实现很简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Event = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  Event.on = <span class="function"><span class="keyword">function</span> (<span class="params">type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._cbQueue = <span class="keyword">this</span>._cbQueue || &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>._cbQueue[type] = <span class="keyword">this</span>._cbQueue[type]|| [];</span><br><span class="line">    <span class="keyword">this</span>._cbQueue[type].push(handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Event.emit = <span class="function"><span class="keyword">function</span> (<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._cbQueue[type]) &#123;</span><br><span class="line">      <span class="keyword">this</span>._cbQueue[type].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">        cb(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  exports.Event = Event;</span><br><span class="line"></span><br><span class="line">&#125;(global));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Test 1</span></span><br><span class="line">Event.on(<span class="string">"test"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">Event.on(<span class="string">"test"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"test"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">Event.emit(<span class="string">"test"</span>, <span class="string">"hello world"</span>); <span class="comment">// 输出“hello world”和”test”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Test2</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(person1, Event);</span><br><span class="line"><span class="built_in">Object</span>.assign(person2, Event);</span><br><span class="line"></span><br><span class="line">person1.on(<span class="string">"call1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"person1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">person2.on(<span class="string">"call2"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"person2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person1.emit(<span class="string">"call1"</span>); <span class="comment">// 输出“person1”</span></span><br><span class="line">person1.emit(<span class="string">"call2"</span>); <span class="comment">// 输出”person2”</span></span><br><span class="line">person2.emit(<span class="string">"call1"</span>); <span class="comment">// 输出”person1”</span></span><br><span class="line">person2.emit(<span class="string">"call2"</span>); <span class="comment">// 输出”person2”</span></span><br></pre></td></tr></table></figure><p>测试1的结果如预期一样，然而测试2却出了问题，debug看了一下<code>Event</code>对象，<code>Event.on</code>执行后上面竟然有个可以遍历的属性<code>_cbQueue</code>，而且<code>_cbQueue</code>是一个对象而不是一个字面量，所以在<code>Object.assign()</code>拷贝的过程中，将<code>Event._cbQueue</code>对象引用赋值给了<code>person1._cbQueue</code>和<code>person2._cbQueue</code>，也就是说这三者指向了内存中的同一个对象，只要修改一个，其他几个都会跟着修改；当不执行<code>Event.on</code>时，<code>Event</code>上就不会有属性<code>_cbQueue</code>，那么接下来<code>person1</code>和<code>person2</code>执行<code>on</code>方法后，<code>this</code>指向了他们本身，会创造他们自己的互不影响的<code>_cbQueue</code>属性。<br>但不执行<code>Event.on</code>这不是解决的完美办法，不过问题已经定位了，解决也很简单，修改<code>Event</code>对象的属性<code>_cbQueue</code>为不可遍历，让拷贝过程不拷贝属性<code>_cbQueue</code>即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Event = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Event, <span class="string">"_cbQueue"</span>, &#123;</span><br><span class="line">  value : &#123;&#125;,</span><br><span class="line">  writable : <span class="literal">true</span>,</span><br><span class="line">  enumerable : <span class="literal">false</span>,</span><br><span class="line">  configurable : <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Event.on = <span class="function"><span class="keyword">function</span> (<span class="params">type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._cbQueue = <span class="keyword">this</span>._cbQueue || &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>._cbQueue[type] = <span class="keyword">this</span>._cbQueue[type]|| [];</span><br><span class="line">    <span class="keyword">this</span>._cbQueue[type].push(handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Event.emit = <span class="function"><span class="keyword">function</span> (<span class="params">type, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._cbQueue[type]) &#123;</span><br><span class="line">      <span class="keyword">this</span>._cbQueue[type].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">        cb(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  exports.Event = Event;</span><br><span class="line"></span><br><span class="line">&#125;(global));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Test 1</span></span><br><span class="line">Event.on(<span class="string">"test"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">Event.on(<span class="string">"test"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"test"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">Event.emit(<span class="string">"test"</span>, <span class="string">"hello world"</span>); <span class="comment">// 输出“hello world”和”test”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Test2</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(person1, Event);</span><br><span class="line"><span class="built_in">Object</span>.assign(person2, Event);</span><br><span class="line"></span><br><span class="line">person1.on(<span class="string">"call1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"person1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">person2.on(<span class="string">"call2"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"person2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person1.emit(<span class="string">"call1"</span>); <span class="comment">// 输出“person1”</span></span><br><span class="line">person1.emit(<span class="string">"call2"</span>); <span class="comment">// 没有输出</span></span><br><span class="line">person2.emit(<span class="string">"call1"</span>); <span class="comment">// 没有输出</span></span><br><span class="line">person2.emit(<span class="string">"call2"</span>); <span class="comment">// 输出”person2”</span></span><br></pre></td></tr></table></figure><p>这样便算完美实现了题目的要求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实原理很简单，没想到在周边的实现上浪费了一些debug的时间，有些惭愧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要求&quot;&gt;&lt;a href=&quot;#要求&quot; class=&quot;headerlink&quot; title=&quot;要求&quot;&gt;&lt;/a&gt;要求&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;请实现下面的自定义事件Event对象的接口，功能见注释（测试1）&lt;br&gt;该Event对象的接口需要能被其他对象拓展复用（测试2）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://blog.daraw.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://blog.daraw.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>制作列带有斑马条纹背景的表格</title>
    <link href="https://blog.daraw.cn/2016/05/16/table-with-striped-lines/"/>
    <id>https://blog.daraw.cn/2016/05/16/table-with-striped-lines/</id>
    <published>2016-05-16T13:27:00.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<p>在切页面时，遇到了一个有趣的表格，如图所示：</p><a id="more"></a><p><img src="/img/table-with-striped-lines0.png" alt>  </p><p>下意识的想到了<code>bootstrap</code>的斑马纹效果table，然而记忆中bs只有行斑马纹效果，至于实现事实上很简单，直接去Github看最终生成的<code>bootstrap.css</code>文件，当前的2321~2323行为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.table-striped</span> &gt; <span class="selector-tag">tbody</span> &gt; <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-of-type(odd)</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f9f9f9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上这给了我一个很好的思路，借助<code>nth-child()</code>选择器，先对每行的奇数<code>td</code>设定背景，连起来就是奇数列做了特殊背景处理，也就是斑马纹效果，然后再对第一行和最后一行做特殊处理让边角圆润，下面贴上自己的代码（主要提供一个思路，css比较烂，请轻喷==）：<br><strong>html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"account-course-lessons"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>L1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>L2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>L3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>L4<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>L5<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>scss</strong>  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span><span class="selector-class">.account-course-lessons</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: rgb(<span class="number">221</span>, <span class="number">221</span>, <span class="number">221</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">tr</span> &#123;</span><br><span class="line">    <span class="selector-tag">td</span> &#123;</span><br><span class="line">      <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid rgb(<span class="number">215</span>, <span class="number">215</span>, <span class="number">215</span>);</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line"></span><br><span class="line">      <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: gray;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">1em</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">tr</span> &#123;</span><br><span class="line">    <span class="selector-tag">td</span><span class="selector-pseudo">:nth-child</span>(2n+1) &#123;</span><br><span class="line">      <span class="attribute">background-color</span>: rgb(<span class="number">235</span>, <span class="number">235</span>, <span class="number">235</span>);</span><br><span class="line">      <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid rgb(<span class="number">215</span>, <span class="number">215</span>, <span class="number">215</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(1) &#123;</span><br><span class="line">    <span class="selector-tag">td</span><span class="selector-pseudo">:nth-child</span>(2n+1) &#123;</span><br><span class="line">      <span class="attribute">background-color</span>: rgb(<span class="number">235</span>, <span class="number">235</span>, <span class="number">235</span>);</span><br><span class="line">      <span class="attribute">border-top</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">      <span class="attribute">border-left</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">      <span class="attribute">border-right</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">      <span class="attribute">border-radius</span>: <span class="number">20px</span> <span class="number">20px</span> <span class="number">0</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-last-child</span>(1) &#123;</span><br><span class="line">    <span class="selector-tag">td</span><span class="selector-pseudo">:nth-child</span>(2n+1) &#123;</span><br><span class="line">      <span class="attribute">background-color</span>: rgb(<span class="number">235</span>, <span class="number">235</span>, <span class="number">235</span>);</span><br><span class="line">      <span class="attribute">border-bottom</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">      <span class="attribute">border-left</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">      <span class="attribute">border-right</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">      <span class="attribute">border-radius</span>:  <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">20px</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">td</span> &#123;</span><br><span class="line">      <span class="attribute">border-bottom</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在切页面时，遇到了一个有趣的表格，如图所示：&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.daraw.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="https://blog.daraw.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>git用户名莫名其妙变化及挽救措施</title>
    <link href="https://blog.daraw.cn/2016/04/22/git-commit-name-change/"/>
    <id>https://blog.daraw.cn/2016/04/22/git-commit-name-change/</id>
    <published>2016-04-22T09:59:00.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚提交了一次commit并推到github的远程仓库后，突然发现最近的commit提交都没有记录到contributions里，而且commit记录中我的头像无法正常显示。  </p><a id="more"></a><p>查了一下查到了github的帮助文档：</p><ul><li><a href="https://help.github.com/articles/why-are-my-contributions-not-showing-up-on-my-profile/" target="_blank" rel="noopener">Why are my contributions not showing up on my profile?</a></li><li><a href="https://help.github.com/articles/changing-author-info/" target="_blank" rel="noopener">Changing author info</a></li></ul><p>英语不好的还可以看看这篇博客：<a href="https://segmentfault.com/a/1190000004318632" target="_blank" rel="noopener">为什么Github没有记录你的Contributions</a>  </p><p>在本地仓库目录下<code>git log</code>查看了历史记录，发现出问题的那几次的用户名变成了windows的用户名，邮箱也是用户名。<br>按照帮助文档修复了commit作者信息，并提交了github的远程仓库后，终于正常了。  </p><p>最后，在git bash中设定好git配置文件的用户信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "CodeDaraW"</span><br><span class="line">git config --global user.email "CodeDaraW@gmail.com"</span><br></pre></td></tr></table></figure><p>一切就正常了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨晚提交了一次commit并推到github的远程仓库后，突然发现最近的commit提交都没有记录到contributions里，而且commit记录中我的头像无法正常显示。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="https://blog.daraw.cn/categories/git/"/>
    
    
      <category term="git" scheme="https://blog.daraw.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>记一次前端性能优化实战</title>
    <link href="https://blog.daraw.cn/2016/03/03/note-for-optimization-of-online-shop/"/>
    <id>https://blog.daraw.cn/2016/03/03/note-for-optimization-of-online-shop/</id>
    <published>2016-03-03T00:00:00.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这学期开学时去找了信息化中心的老师，说明了自己想往Node和Python方向走的想法，退出了信息化中心的学生工作室。<br>然而上周六老师又找到了我，他们对一个电商网站项目的前端性能很不满意，希望我能给他们做一套性能优化方案。</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>和老师面谈后，确定了需要下面几个主要需求：  </p><ul><li>合并css/js文件减少http请求</li><li>压缩css/js文件减少流量</li><li>原来的模板中每个小icon都是一张图片，用雪碧图/base64减少http请求</li><li>大图懒加载，减轻后端压力</li></ul><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>常见的构建方案就是grunt,gulp,webpack,make,npm script，还有国内百度的fis。<br>经过了筛选省下了gulp和fis3两个选择，不得不说fis3已经做好了一套默认方案，几乎和信息中心的要求相符，然而经过测试发现这个项目使用gulp构建更加快一些。<br>确定了gulp后，接下来就是对照需求选插件了。</p><ul><li>开发时实时监听变化自动刷新<br>借助<code>gulp-livereload</code>插件和chrome的<code>livereload</code>插件，<code>gulpfile</code>中创建名为<code>watch</code>的<code>task</code>，监听文件变动浏览器自动刷新，解放浏览器的刷新按钮和键盘的F5。</li><li>合并js/css文件<br>为了方便开发时多个文件引入，和模块化的开发，一开始使用了<code>gulp-usemin</code>插件，使用起来确实挺方便的，然而发现在多个页面构建时就废了，查了一下发现npm建议使用<code>gulp-useref</code>代替。<br>然而接着发现<code>gulp-useref</code>不能将外联转化为内联，而且在流中处理了文件名后不会像<code>gulp-usemin</code>自动修改引用文件的地址，好在有<code>gulp-rev-replace</code>插件可以自动在流中修改html文件中的引用地址。<br>而将外联文件合并为内联文件则可以用<code>gulp-inline-source</code>插件，和<code>gulp-usemin</code>差不多。</li><li>js/css文件压缩<br>分别用<code>gulp-uglify</code>和<code>gulp-cssnano</code>插件，这个没什么好说的。</li><li>版本更迭css/js文件冗余<br>常见的有文件名加时间戳和hash两种方案，选哪个倒感觉无所谓了，这边用<code>gulp-rev</code>插件实现hash冗余文件，服务器端静态资源半年清理个一次也就差不多了。</li><li>小图优化<br>常见的就是把小图转成字体文件，SVG，雪碧图，base64这几种方案。<br>这边选择了base64，其实base64有利有害，合并进css文件会变大1/3左右，而且css文件太大后会延长css文件渲染时间。这边我设定的5KB为阈值，css文件大概增加了100k，影响不大，图片跟着css文件一起缓存，倒也不错。</li><li>大图懒加载<br>由于原来就使用了jquery，于是用了百度改过的jquery图片懒加载插件，这里遇到了一个大坑。<br>假设<code>html</code>中有两个<code>div</code>，通过css将第一块放在左边当作侧栏，第二块放在右边当作主栏，将所有图片都做懒加载处理，如果左栏高度过高，左栏看完了右栏才能开始加载。<br>鹅厂的大牛张鑫旭曾经也写过一个这样的插件。这类的插件原理都类似，大致看了下源码，猜测是插件设计时没有想到这种场景，所以出现了这种蜜汁bug。<br>突然想起来，百度说他的百度地图和糯米都用了这个插件，那不如去看看他们怎么解决的。<br>看了下糯米的页面，原来他们不对侧栏做懒加载处理。我取消了侧栏的懒加载处理，果然就正常了。</li></ul><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>这是第一次将这些优化方案在这样一个较大的项目中使用，这个项目还没有结束，如果有新的变化视情况来更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这学期开学时去找了信息化中心的老师，说明了自己想往Node和Python方向走的想法，退出了信息化中心的学生工作室。&lt;br&gt;然而上周六老师又找到了我，他们对一个电商网站项目的前端性能很不满意，希望我能给他们做一套性能优化方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.daraw.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="gulp" scheme="https://blog.daraw.cn/tags/gulp/"/>
    
      <category term="性能优化" scheme="https://blog.daraw.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>将setTimeout函数队列</title>
    <link href="https://blog.daraw.cn/2016/02/12/queue-several-functions-set-by-timeout/"/>
    <id>https://blog.daraw.cn/2016/02/12/queue-several-functions-set-by-timeout/</id>
    <published>2016-02-12T14:36:41.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>先来看一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3000ms'</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'first'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1000ms'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'second'</span>);</span><br></pre></td></tr></table></figure><p>控制台输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first</span><br><span class="line">second</span><br><span class="line">1000ms</span><br><span class="line">3000ms</span><br></pre></td></tr></table></figure><p>如果我们想让第一个定时器的回调函数执行完再执行第二个定时器的回调函数该怎么做呢？</p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>JavaScript一开始作为浏览器脚本语言出现，为了避免多线程带来的管理问题，被设计成了单线程，即使是Node.js中的<code>cluster</code>以及Web Worker也并没有改变JS单线程的本质。<br>单线程意味着阻塞，所有的任务要排队执行，前一个任务未执行完下一个任务是不会执行的。如果有一个任务耗时很长，那么后面的任务也只有干等着。为了解决这个问题，JS内部还有一个消息队列，并采用EventLoop来处理消息队列中的消息。<br>在上述栗子中，<code>setTimeout</code>会在指定的时间向消息队列中添加一条消息，在消息得到处理的时候也就是回调函数执行的时候，而主线程中的<code>console.log</code>不会等待，所以上述栗子中先按顺序执行了两个<code>console.log</code>，然后才按照定时分别执行1000ms和3000ms时的回调函数。<br>关于JS的单线程的问题这里不做更多解释，想了解更多的话可以看看下面参考中的阮一峰老师的<a href="http://javascript.ruanyifeng.com/bom/engine.html" target="_blank" rel="noopener">浏览器的JavaScript引擎</a>，讲的非常易懂。  </p><p>那么上述问题中的需求就是说，如何做到在第一个定时器的回调函数执行后，第二个定时器才开始定时并等待执行回调函数。<br>最容易想到了方法就是回调函数。封装定时器，在回调中执行下一个封装函数，但这会导致一个问题，在稍微复杂的情况下，出现“回调地狱”，相信Node.js党应该对回调有着别样的感情。<br>So，回调函数并不是一个cool的解决方案。  </p><p>这里的另一个思路就是再构造一个函数队列，封装定时器，给定时器加锁，将其锁在一个函数里，只有确认执行结束才会执行队列中的下一个封装的定时器。  </p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>在StackOverflow上有个哥们提了个和我一样的问题，其中一个答案给了一个demo，我这里简化了一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveOne</span>(<span class="params">arg1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg1)&#123;</span><br><span class="line">        arg1 = <span class="literal">false</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;recursiveOne(arg1);&#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"func1 complete"</span>);</span><br><span class="line">        coreFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveTwo</span>(<span class="params">arg1</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arg1)&#123;</span><br><span class="line">        arg1 = <span class="literal">false</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;recursiveTwo(arg1);&#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"func2 complete"</span>);</span><br><span class="line">        coreFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveThree</span>(<span class="params">arg1</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arg1)&#123;</span><br><span class="line">        arg1 = <span class="literal">false</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;recursiveThree(arg1);&#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"func3 complete"</span>);</span><br><span class="line">        coreFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcSet = [recursiveOne, recursiveTwo, recursiveThree];</span><br><span class="line"><span class="keyword">var</span> funcArgs = [[<span class="literal">true</span>], [<span class="literal">true</span>], [<span class="literal">true</span>]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coreFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(funcSet.length)&#123;</span><br><span class="line">        <span class="keyword">var</span> func = funcSet.shift();</span><br><span class="line">        func.apply(global, funcArgs.shift())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coreFunction();</span><br></pre></td></tr></table></figure><p>免去了层层回调，优雅的解决的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun1 complete</span><br><span class="line">fun2 complete</span><br><span class="line">fun3 complete</span><br></pre></td></tr></table></figure><p>那么在实际开发环境如何可控的操作执行队列和锁呢？<br>构造一个入队函数，和出队执行函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcSet = [],</span><br><span class="line">    funcArgs = [],</span><br><span class="line">    funcCont = [],</span><br><span class="line">    isRunning = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enQueue</span>(<span class="params">fn, context, args</span>) </span>&#123;</span><br><span class="line">    funcSet.push(fn);</span><br><span class="line">    funcCont.push(context);</span><br><span class="line">    funcArgs.push(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRunning) &#123;</span><br><span class="line">        isRunning = <span class="literal">true</span>;</span><br><span class="line">        coreFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coreFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(funcSet.length)&#123;</span><br><span class="line">        funcSet.shift().apply(funcCont.shift(), [].concat(funcArgs.shift()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveOne</span>(<span class="params">arg1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg1)&#123;</span><br><span class="line">        arg1 = <span class="literal">false</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;recursiveOne(arg1);&#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"func1 complete"</span>);</span><br><span class="line">        coreFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveTwo</span>(<span class="params">arg1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg1)&#123;</span><br><span class="line">        arg1 = <span class="literal">false</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;recursiveTwo(arg1);&#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"func2 complete"</span>);</span><br><span class="line">        coreFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveThree</span>(<span class="params">arg1</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arg1)&#123;</span><br><span class="line">        arg1 = <span class="literal">false</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;recursiveThree(arg1);&#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"func3 complete"</span>);</span><br><span class="line">        coreFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcSet = [],</span><br><span class="line">    funcArgs = [],</span><br><span class="line">    funcCont = [],</span><br><span class="line">    isRunning = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enQueue</span>(<span class="params">fn, context, args</span>) </span>&#123;</span><br><span class="line">    funcSet.push(fn);</span><br><span class="line">    funcCont.push(context);</span><br><span class="line">    funcArgs.push(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRunning) &#123;</span><br><span class="line">        isRunning = <span class="literal">true</span>;</span><br><span class="line">        coreFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coreFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(funcSet.length)&#123;</span><br><span class="line">        funcSet.shift().apply(funcCont.shift(), [].concat(funcArgs.shift()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enQueue(recursiveOne, <span class="keyword">this</span>, <span class="literal">true</span>);</span><br><span class="line">enQueue(recursiveTwo, <span class="keyword">this</span>, <span class="literal">true</span>);</span><br><span class="line">enQueue(recursiveThree, <span class="keyword">this</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://javascript.ruanyifeng.com/bom/engine.html" target="_blank" rel="noopener">浏览器的JavaScript引擎</a>  </li><li><a href="http://stackoverflow.com/questions/12839488/how-to-queue-several-functions-set-by-settimeout-with-js-jquery" target="_blank" rel="noopener">How to queue several functions set by setTimeout with JS/jQuery</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;先来看一段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;3000ms&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;3000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;first&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;1000ms&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;second&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;控制台输出为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;first&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;second&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1000ms&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3000ms&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果我们想让第一个定时器的回调函数执行完再执行第二个定时器的回调函数该怎么做呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://blog.daraw.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://blog.daraw.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>gulp构建中del的一个小坑</title>
    <link href="https://blog.daraw.cn/2016/02/12/a-problem-about-gulp-del/"/>
    <id>https://blog.daraw.cn/2016/02/12/a-problem-about-gulp-del/</id>
    <published>2016-02-12T12:55:15.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>grunt，gulp以及webpack三个常见构建工具的对比和介绍已经很多了，这里就不再赘述。手上这个项目用了gulp进行构建，同时也是我刚刚入门学习使用gulp构建。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在写<code>gulpfile.js</code>的task时，一开始我是这么写的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    del([<span class="string">'typing.min.js'</span>], cb);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'build'</span>, [<span class="string">'clean'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    gulp.src(<span class="string">'typing.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(rename(<span class="string">'typing.min.js'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">''</span>));</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'clean'</span>, <span class="string">'build'</span>]);</span><br></pre></td></tr></table></figure><p>在<code>shell</code>里执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp build</span><br></pre></td></tr></table></figure><p>始终只进行了<code>clean</code>任务而不<code>build</code>，对着API和一些介绍gulp的文章，怎么都找不到问题所在。  </p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>接着搜到了一句话：</p><blockquote><p>Make sure to return the stream so that gulp knows the clean task is asynchronous and waits for it to terminate before starting the dependent one.</p></blockquote><p>由于del是异步执行的，尝试在<code>clean</code>任务中返回流后就正常了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> del([<span class="string">'typing.min.js'</span>], cb);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另外在github的del项目的<a href="https://github.com/sindresorhus/del/issues/50" target="_blank" rel="noopener">issues</a>中看到一个哥们提供的解决方案，其中一个是返回流，另一个则是常见的解决方案：回调。</p><h2 id="构建的其他方案"><a href="#构建的其他方案" class="headerlink" title="构建的其他方案"></a>构建的其他方案</h2><p>在学长ChiChou的技术群里，学长告诉我在这种无需大量文件操作的项目中，可以用<code>package.json</code>+<code>Makefile</code>进行构建，甚至可以连这都不用，直接在<code>package.json</code>中的scripts中写入指令，然后<code>npm run xxxx</code>执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;grunt，gulp以及webpack三个常见构建工具的对比和介绍已经很多了，这里就不再赘述。手上这个项目用了gulp进行构建，同时也是我刚刚入门学习使用gulp构建。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.daraw.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="gulp" scheme="https://blog.daraw.cn/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>CSS画三角形引发的一些思考</title>
    <link href="https://blog.daraw.cn/2015/08/31/thoughts-about-drawing-triangle-with-css/"/>
    <id>https://blog.daraw.cn/2015/08/31/thoughts-about-drawing-triangle-with-css/</id>
    <published>2015-08-31T00:00:00.000Z</published>
    <updated>2019-12-19T08:47:41.553Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天刷知乎时看到了一个问题，<a href="http://www.zhihu.com/question/35180018" target="_blank" rel="noopener">有谁能详细讲一下css如何画出一个三角形？怎么想都想不懂？ - 知乎</a>。很巧，刚入前端坑的我前不久也遇到过这个问题，今天再来谈一谈这个问题则是因为知乎的一些答案引发了我的更深的思考。  </p><a id="more"></a><p>&emsp;&emsp;第一次遇到这个问题是在撸Bootstrap的一个demo ——<a href="http://v3.bootcss.com/examples/blog/" target="_blank" rel="noopener">Blog Template for Bootstrap</a>，它的导航栏中用到了CSS来画三角形：<br><img src="/img/20150831231156.png" alt="截图1"><br>我们来看一看其中重点的那段CSS代码：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.blog-nav</span> <span class="selector-class">.active</span><span class="selector-pseudo">:after</span> &#123;  </span><br><span class="line">      <span class="attribute">position</span>: absolute;  </span><br><span class="line">      <span class="attribute">bottom</span>: <span class="number">0</span>;  </span><br><span class="line">      <span class="attribute">left</span>: <span class="number">50%</span>;  </span><br><span class="line">      <span class="attribute">width</span>: <span class="number">0</span>;  </span><br><span class="line">      <span class="attribute">height</span>: <span class="number">0</span>;  </span><br><span class="line">      <span class="attribute">margin-left</span>: -<span class="number">5px</span>;  </span><br><span class="line">      <span class="attribute">vertical-align</span>: middle;  </span><br><span class="line">      <span class="attribute">content</span>: <span class="string">" "</span>;  </span><br><span class="line">      <span class="attribute">border-right</span>: <span class="number">5px</span> solid transparent;  </span><br><span class="line">      <span class="attribute">border-bottom</span>: <span class="number">5px</span> solid;  </span><br><span class="line">      <span class="attribute">border-left</span>: <span class="number">5px</span> solid transparent;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这只是一段简单的用CSS画出等腰直角三角形的实现案例，当时我在SF的一篇文章找到了答案：<a href="http://segmentfault.com/a/1190000000652249" target="_blank" rel="noopener">图解利用CSS实现三角形 - SegmentFault</a>，通过这篇文章，我明白了原来border是一个梯形，当梯形的上底为0的极限情况时，梯形就成了一个三角形，画一个正方形，正方形的div为0时，隐藏三条border，剩下的可见的border便是所需的三角形。于是bootstrap的demo中的问题迎刃而解。<br>&emsp;&emsp;然而，bootstrap的demo中的等边直角三角形是一个非常经典的情况，那么画任意三角形的时候怎么办呢？知乎的<a href="http://www.zhihu.com/people/vkki" target="_blank" rel="noopener">@Vkki</a>用户给出了结论：  </p><blockquote><p>（上边的 width 控制了这个三角形上顶点离 div 边缘的距离是 10px）<br>下边的 width 控制了三角形的高（150px）<br>左右两边的 width 分别控制了三角形的底边长的两部分（加起来共 200px）<br><img src="/img/Vkki.png" alt="Vkki"><br><img src="/img/Vkki2.png" alt="Vkki">  </p></blockquote><p>&emsp;&emsp;记住结论固然重要，然而我又引发了好奇心，如果左右上下四边的width不相等的情况下，各个border又是什么样的的？<br>&emsp;&emsp;于是我画了一个div，CSS代码如下：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;  </span><br><span class="line">      <span class="attribute">width</span>:<span class="number">0</span>;  </span><br><span class="line">      <span class="attribute">height</span>:<span class="number">0</span>;  </span><br><span class="line">      <span class="attribute">border-top</span>:<span class="number">100px</span> solid;  </span><br><span class="line">      <span class="attribute">border-bottom</span>:<span class="number">125px</span> solid;  </span><br><span class="line">      <span class="attribute">border-left</span>:<span class="number">150px</span> solid;  </span><br><span class="line">      <span class="attribute">border-right</span>:<span class="number">175px</span> solid;  </span><br><span class="line">      <span class="attribute">border-color</span>:red green blue yellow;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在浏览器中的效果图：<br><img src="/img/20150831235000.png" alt="效果图"><br>&emsp;&emsp;结果和预想的有点不一样，但是结合上面的结论，已经非常好理解了：）<br>&emsp;&emsp;其实在回答中，<a href="http://www.zhihu.com/people/wang-xiao-9-14" target="_blank" rel="noopener">@王潇</a>的答案也让我想到了很多，他利用CSS3中transform属性的shewX()方法以及rotate()方法还有活用skewX()方法画出了一般形状的三角形，和其他答案不一样的思路确实让我眼前一亮，想起了强大的CSS3，利用CSS3的新特性可以完成很多以前只能用js实现的效果，真棒！当然，付出的代价是兼容性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;今天刷知乎时看到了一个问题，&lt;a href=&quot;http://www.zhihu.com/question/35180018&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有谁能详细讲一下css如何画出一个三角形？怎么想都想不懂？ - 知乎&lt;/a&gt;。很巧，刚入前端坑的我前不久也遇到过这个问题，今天再来谈一谈这个问题则是因为知乎的一些答案引发了我的更深的思考。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.daraw.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://blog.daraw.cn/tags/CSS/"/>
    
  </entry>
  
</feed>
