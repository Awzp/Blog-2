title: Vue响应式原理之Watcher
date: 2017-03-17 22:59:15
categories: [前端, Vue]
tags: [Vue, Watcher]
---
最近在看Vue的响应式原理时明白了Vue的一些具体的优化手段，在一个数据被操作2次的时候DOM并不会一定跟着修改2次，正常情况下只有一次的修改。  
首先Vue响应式原理的大概内容是借助`getter`和`setter`来劫持数据的变动的，之前我也曾经写过一篇文章来分析数据绑定的几种实现（[如何监听JS变量的变化](https://blog.daraw.cn/2016/08/17/how-to-monitor-changes-of-js-variable/)），但是最近稍微深入了解了Vue的实现原理后发现Vue其实是要比想象中实现的巧妙多了。  
<!-- more -->
在阅读[Vue 源码解析：深入响应式原理](https://juejin.im/entry/5834992667f356006c395b31)的时候，明白了Vue在`getter`中收集变量的依赖，在`setter`中通知变量的变化。Vue的内部并不是简单粗暴的把监测钩子插在`setter`和`getter`中，而是巧妙的使用了观察者模式（Pub/Sub）,`Dep`就是其实现。而模版中的指令和数值检测的绑定则通过`Watcher`来完成，每个被监测的变量会被分配一个`Watcher`，每个`Watcher`都有一个`id`来做去重。  
在被检测的数值发生变化时，`setter`中通过`dep.notify`来发布通知，通知所有的`Watcher`实例调用`update`方法，而在大多数情况下，`Watcher`实例调用`update`又会把自身放入一个队列中，在下一次事件循环中执行`flushSchedulerQueue`来一起更新。这一块是用自定义的`nextTick`函数来做的，这个函数的实现已经有很多的文章进行的讲解，知乎上也有过讨论，这里不再赘述。  
这个时候我产生了一个很智障的想法，既然每个被监测的变量对应了一个`Watcher`实例，那么假设`vm`上有一个值`x`，初始值为`1`，`vm.x++`连续同步执行两次，第一次执行的时候其`Watcher`实例被推入了更新队列中，第二次的时候在`queueWatcher`中是有一个`has`对象当作`Map`来使用，判断是否已经存在`id`对应的对象来决定要不要推入队列的，`vm.x`的`Watcher`已经被推入过一次，是不会再次被推入的，那么第二次变动是不是会被直接忽略？直觉告诉我`Vue`肯定不会犯这种低级错误啊！然而这块的代码其实还是有点绕的，虽然读懂了大概的流程，但是有的细节处理不是一时半会儿就能直接理解的。  
晚上刷知乎的时候看到了一个高赞回答，讲的是如何使用Chrome的断点调试功能查看`React`的`this.setState`背后发生了什么，我突然想到既然自己看代码不能理解，那么打断点跑一下不就好了！  
在Chrome中打断点跑了一遍后我突然想明白过来了，事实上`vm`上的变量和`DOM`上的展示并不是完全实时映射的啊，在`vm.x++`第一次执行后`vm.x`就已经被认为是脏的了，下一次清空`watcher`队列的时候他肯定是会进行处理的的，而这个时候，`vm.x`的值已经是`2`了；在执行完第二次的自增操作后，`vm.x`的值变成了`3`，这时候如果主线程中没有其他的操作（这一轮`EventLoop`的`Macrotask`队列已经清空了），就会去清空`Watcher`实例队列，而这时候`DOM`才会更新到`vm.x`的值所对应的样子。  
### 后话
上面的解释是基于`Vue2.2.1`来分析的，的这里再做一个大胆的猜测，不过我还没有去看源码来验证，`Vue2`在加入虚拟DOM后，除了能够让Weex和SSR这些多端渲染的实现变得更加容易外，其实也是能够有一定的优化的，假设`vm.x++`后紧跟一个`vm.x--`，`x`虽然是脏的了，但是`x`并没有发生什么变动，那么可以在V DOM在Diff的时候会把`x`对应的依赖的DOM修改忽略掉，兼具了依赖收集和虚拟DOM的优点，当然也会付出依赖收集和虚拟DOM的内存占用和计算的成本。
### 参考资料&推荐阅读
- [Vue 源码解析：深入响应式原理](https://juejin.im/entry/5834992667f356006c395b31)
- [Vue 中如何使用 MutationObserver 做批量处理？](https://www.zhihu.com/question/55364497)
